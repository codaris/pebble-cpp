<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pebble Foundation Classes: Dictionary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pebble Foundation Classes
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">C++ for Pebble</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__Dictionary.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Dictionary<div class="ingroups"><a class="el" href="group__Foundation.html">Foundation</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Data serialization utilities.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Dictionary:</div>
<div class="dyncontent">
<div class="center"><img src="group__Dictionary.png" border="0" usemap="#group____Dictionary" alt=""/></div>
<map name="group____Dictionary" id="group____Dictionary">
<area shape="rect" href="group__Foundation.html" title=" " alt="" coords="5,5,100,31"/>
<area shape="rect" title="Data serialization utilities." alt="" coords="148,5,237,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTuplet.html">Tuplet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8d30623394e3c7e368ea9403412e9c79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga8d30623394e3c7e368ea9403412e9c79">TupletBytes</a>(_key,  _data,  _length)&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a>, .key = _key, .bytes = { .data = _data, .length = _length }})</td></tr>
<tr class="separator:ga8d30623394e3c7e368ea9403412e9c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc99ab1d451b29385733bb92f3c937a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga6bc99ab1d451b29385733bb92f3c937a">TupletCString</a>(_key,  _cstring)&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a>, .key = _key, .cstring = { .data = _cstring, .length = _cstring ? strlen(_cstring) + 1 : 0 }})</td></tr>
<tr class="separator:ga6bc99ab1d451b29385733bb92f3c937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152caed0a3d5db76c063b69a01157e57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga152caed0a3d5db76c063b69a01157e57">TupletInteger</a>(_key,  _integer)&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = IS_SIGNED(_integer) ? <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> : <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a>, .key = _key, .integer = { .storage = _integer, .width = sizeof(_integer) }})</td></tr>
<tr class="separator:ga152caed0a3d5db76c063b69a01157e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d30623394e3c7e368ea9403412e9c79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga8d30623394e3c7e368ea9403412e9c79">TupletBytes</a>(_key,  _data,  _length)&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a>, .key = _key, .bytes = { .data = _data, .length = _length }})</td></tr>
<tr class="separator:ga8d30623394e3c7e368ea9403412e9c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc99ab1d451b29385733bb92f3c937a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga6bc99ab1d451b29385733bb92f3c937a">TupletCString</a>(_key,  _cstring)&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a>, .key = _key, .cstring = { .data = _cstring, .length = _cstring ? strlen(_cstring) + 1 : 0 }})</td></tr>
<tr class="separator:ga6bc99ab1d451b29385733bb92f3c937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152caed0a3d5db76c063b69a01157e57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga152caed0a3d5db76c063b69a01157e57">TupletInteger</a>(_key,  _integer)&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = IS_SIGNED(_integer) ? <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> : <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a>, .key = _key, .integer = { .storage = _integer, .width = sizeof(_integer) }})</td></tr>
<tr class="separator:ga152caed0a3d5db76c063b69a01157e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga95232b296908a30079adbfcb4f71a26e"><td class="memItemLeft" align="right" valign="top"><a id="ga95232b296908a30079adbfcb4f71a26e"></a>
typedef struct Dictionary&#160;</td><td class="memItemRight" valign="bottom"><b>Dictionary</b></td></tr>
<tr class="separator:ga95232b296908a30079adbfcb4f71a26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257454e97afac51fdc4f2ce6c891b948"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structTuplet.html">Tuplet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga257454e97afac51fdc4f2ce6c891b948">Tuplet</a></td></tr>
<tr class="separator:ga257454e97afac51fdc4f2ce6c891b948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac42a608a61e00467c9d2c98bbc512458"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gac42a608a61e00467c9d2c98bbc512458">DictionarySerializeCallback</a>) (const uint8_t *const data, const uint16_t size, void *context)</td></tr>
<tr class="separator:gac42a608a61e00467c9d2c98bbc512458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dcb8cc0ffca04141354048a6e3bd379"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga9dcb8cc0ffca04141354048a6e3bd379">DictionaryKeyUpdatedCallback</a>) (const uint32_t key, const Tuple *new_tuple, const Tuple *old_tuple, void *context)</td></tr>
<tr class="separator:ga9dcb8cc0ffca04141354048a6e3bd379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95232b296908a30079adbfcb4f71a26e"><td class="memItemLeft" align="right" valign="top"><a id="ga95232b296908a30079adbfcb4f71a26e"></a>
typedef struct Dictionary&#160;</td><td class="memItemRight" valign="bottom"><b>Dictionary</b></td></tr>
<tr class="separator:ga95232b296908a30079adbfcb4f71a26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257454e97afac51fdc4f2ce6c891b948"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structTuplet.html">Tuplet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga257454e97afac51fdc4f2ce6c891b948">Tuplet</a></td></tr>
<tr class="separator:ga257454e97afac51fdc4f2ce6c891b948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac42a608a61e00467c9d2c98bbc512458"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gac42a608a61e00467c9d2c98bbc512458">DictionarySerializeCallback</a>) (const uint8_t *const data, const uint16_t size, void *context)</td></tr>
<tr class="separator:gac42a608a61e00467c9d2c98bbc512458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dcb8cc0ffca04141354048a6e3bd379"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga9dcb8cc0ffca04141354048a6e3bd379">DictionaryKeyUpdatedCallback</a>) (const uint32_t key, const Tuple *new_tuple, const Tuple *old_tuple, void *context)</td></tr>
<tr class="separator:ga9dcb8cc0ffca04141354048a6e3bd379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaafae887a6d07cde8d11885c755b55351"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> { <br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> = 1 &lt;&lt; 1, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> = 1 &lt;&lt; 2, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876">DICT_INTERNAL_INCONSISTENCY</a> = 1 &lt;&lt; 3, 
<br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045">DICT_MALLOC_FAILED</a> = 1 &lt;&lt; 4, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> = 1 &lt;&lt; 1, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> = 1 &lt;&lt; 2, 
<br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876">DICT_INTERNAL_INCONSISTENCY</a> = 1 &lt;&lt; 3, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045">DICT_MALLOC_FAILED</a> = 1 &lt;&lt; 4
<br />
 }</td></tr>
<tr class="memdesc:gaafae887a6d07cde8d11885c755b55351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values for dictionary write/conversion functions.  <a href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">More...</a><br /></td></tr>
<tr class="separator:gaafae887a6d07cde8d11885c755b55351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf164f32d9bda6829f1738ef3fb2c6670"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">TupleType</a> { <br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a> = 1, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a> = 2, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a> = 1, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a> = 2, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:gaf164f32d9bda6829f1738ef3fb2c6670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values representing the type of data that the <code>value</code> field of a Tuple contains.  <a href="group__Dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">More...</a><br /></td></tr>
<tr class="separator:gaf164f32d9bda6829f1738ef3fb2c6670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafae887a6d07cde8d11885c755b55351"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> { <br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> = 1 &lt;&lt; 1, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> = 1 &lt;&lt; 2, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876">DICT_INTERNAL_INCONSISTENCY</a> = 1 &lt;&lt; 3, 
<br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045">DICT_MALLOC_FAILED</a> = 1 &lt;&lt; 4, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> = 1 &lt;&lt; 1, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> = 1 &lt;&lt; 2, 
<br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876">DICT_INTERNAL_INCONSISTENCY</a> = 1 &lt;&lt; 3, 
<a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045">DICT_MALLOC_FAILED</a> = 1 &lt;&lt; 4
<br />
 }</td></tr>
<tr class="memdesc:gaafae887a6d07cde8d11885c755b55351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values for dictionary write/conversion functions.  <a href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">More...</a><br /></td></tr>
<tr class="separator:gaafae887a6d07cde8d11885c755b55351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf164f32d9bda6829f1738ef3fb2c6670"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">TupleType</a> { <br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a> = 1, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a> = 2, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a> = 0, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a> = 1, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a> = 2, 
<a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:gaf164f32d9bda6829f1738ef3fb2c6670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values representing the type of data that the <code>value</code> field of a Tuple contains.  <a href="group__Dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">More...</a><br /></td></tr>
<tr class="separator:gaf164f32d9bda6829f1738ef3fb2c6670"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0551d069624fb5bfc066fecfa4153bde"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga0551d069624fb5bfc066fecfa4153bde">dict_calc_buffer_size</a> (const uint8_t tuple_count,...)</td></tr>
<tr class="separator:ga0551d069624fb5bfc066fecfa4153bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7fbb0db218e7e6f59eccfa2650fd645"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gaa7fbb0db218e7e6f59eccfa2650fd645">dict_size</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter)</td></tr>
<tr class="separator:gaa7fbb0db218e7e6f59eccfa2650fd645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec44fce51a2ce464a954b2bdd240ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga9ec44fce51a2ce464a954b2bdd240ded">dict_write_begin</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, uint8_t *const buffer, const uint16_t size)</td></tr>
<tr class="separator:ga9ec44fce51a2ce464a954b2bdd240ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30091feef740732d5d6bc3cf2312642a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga30091feef740732d5d6bc3cf2312642a">dict_write_data</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const uint8_t *const data, const uint16_t size)</td></tr>
<tr class="separator:ga30091feef740732d5d6bc3cf2312642a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015dfe89d0ee2f8b4e16ddda21bcf556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga015dfe89d0ee2f8b4e16ddda21bcf556">dict_write_cstring</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const char *const cstring)</td></tr>
<tr class="separator:ga015dfe89d0ee2f8b4e16ddda21bcf556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c4675ccaca8f466f87efb43ae2b2da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga8c4675ccaca8f466f87efb43ae2b2da5">dict_write_int</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const void *integer, const uint8_t width_bytes, const bool is_signed)</td></tr>
<tr class="separator:ga8c4675ccaca8f466f87efb43ae2b2da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fab9c8ce0fdae44a891c6784f4d38a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga8fab9c8ce0fdae44a891c6784f4d38a9">dict_write_uint8</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const uint8_t value)</td></tr>
<tr class="separator:ga8fab9c8ce0fdae44a891c6784f4d38a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33e8aeb09931564c43ac7d0989bd270c"><td class="memItemLeft" align="right" valign="top"><a id="ga33e8aeb09931564c43ac7d0989bd270c"></a>
<a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dict_write_uint16</b> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const uint16_t value)</td></tr>
<tr class="separator:ga33e8aeb09931564c43ac7d0989bd270c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55bc40ddb66d9a0aef4c26ff64c9709e"><td class="memItemLeft" align="right" valign="top"><a id="ga55bc40ddb66d9a0aef4c26ff64c9709e"></a>
<a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dict_write_uint32</b> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const uint32_t value)</td></tr>
<tr class="separator:ga55bc40ddb66d9a0aef4c26ff64c9709e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bccc25123cb35e72ac9a13058669874"><td class="memItemLeft" align="right" valign="top"><a id="ga8bccc25123cb35e72ac9a13058669874"></a>
<a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dict_write_int8</b> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const int8_t value)</td></tr>
<tr class="separator:ga8bccc25123cb35e72ac9a13058669874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ab88d25be7f5910ed679e59462df75"><td class="memItemLeft" align="right" valign="top"><a id="ga16ab88d25be7f5910ed679e59462df75"></a>
<a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dict_write_int16</b> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const int16_t value)</td></tr>
<tr class="separator:ga16ab88d25be7f5910ed679e59462df75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00170057efcbe91274f059b4b1999990"><td class="memItemLeft" align="right" valign="top"><a id="ga00170057efcbe91274f059b4b1999990"></a>
<a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dict_write_int32</b> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key, const int32_t value)</td></tr>
<tr class="separator:ga00170057efcbe91274f059b4b1999990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb27175dd477e85ddd6add9bd1f8989"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga3eb27175dd477e85ddd6add9bd1f8989">dict_write_end</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter)</td></tr>
<tr class="separator:ga3eb27175dd477e85ddd6add9bd1f8989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5d65d21509a42a3113f8b09768d8c5"><td class="memItemLeft" align="right" valign="top">Tuple *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga0d5d65d21509a42a3113f8b09768d8c5">dict_read_begin_from_buffer</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint8_t *const buffer, const uint16_t size)</td></tr>
<tr class="separator:ga0d5d65d21509a42a3113f8b09768d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0494e17cb2cb325f10d7c3172ecd676b"><td class="memItemLeft" align="right" valign="top">Tuple *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga0494e17cb2cb325f10d7c3172ecd676b">dict_read_next</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter)</td></tr>
<tr class="separator:ga0494e17cb2cb325f10d7c3172ecd676b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1443377d1e746e315fc943016885cf2"><td class="memItemLeft" align="right" valign="top">Tuple *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gac1443377d1e746e315fc943016885cf2">dict_read_first</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter)</td></tr>
<tr class="separator:gac1443377d1e746e315fc943016885cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de59736dc56fcda7e4df30ba10ba0cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets</a> (<a class="el" href="group__Dictionary.html#gac42a608a61e00467c9d2c98bbc512458">DictionarySerializeCallback</a> callback, void *context, const <a class="el" href="structTuplet.html">Tuplet</a> *const tuplets, const uint8_t tuplets_count)</td></tr>
<tr class="separator:ga6de59736dc56fcda7e4df30ba10ba0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaaca187fe71e6d2dd8a4eb4deec2069"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gaeaaca187fe71e6d2dd8a4eb4deec2069">dict_serialize_tuplets_to_buffer</a> (const <a class="el" href="structTuplet.html">Tuplet</a> *const tuplets, const uint8_t tuplets_count, uint8_t *buffer, uint32_t *size_in_out)</td></tr>
<tr class="separator:gaeaaca187fe71e6d2dd8a4eb4deec2069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93526111e666de9fdca7276f6ca73c5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga93526111e666de9fdca7276f6ca73c5d">dict_serialize_tuplets_to_buffer_with_iter</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const <a class="el" href="structTuplet.html">Tuplet</a> *const tuplets, const uint8_t tuplets_count, uint8_t *buffer, uint32_t *size_in_out)</td></tr>
<tr class="separator:ga93526111e666de9fdca7276f6ca73c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ed3421ff8e8deda77545aae7d63f191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga5ed3421ff8e8deda77545aae7d63f191">dict_write_tuplet</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const <a class="el" href="structTuplet.html">Tuplet</a> *const tuplet)</td></tr>
<tr class="separator:ga5ed3421ff8e8deda77545aae7d63f191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad31424a83643adbfd9e84c4bd37e4627"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#gad31424a83643adbfd9e84c4bd37e4627">dict_calc_buffer_size_from_tuplets</a> (const <a class="el" href="structTuplet.html">Tuplet</a> *const tuplets, const uint8_t tuplets_count)</td></tr>
<tr class="separator:gad31424a83643adbfd9e84c4bd37e4627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab5934dba34043d2f3319e9ff9dcfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga8ab5934dba34043d2f3319e9ff9dcfc1">dict_merge</a> (<a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *dest, uint32_t *dest_max_size_in_out, <a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *source, const bool update_existing_keys_only, const <a class="el" href="group__Dictionary.html#ga9dcb8cc0ffca04141354048a6e3bd379">DictionaryKeyUpdatedCallback</a> key_callback, void *context)</td></tr>
<tr class="separator:ga8ab5934dba34043d2f3319e9ff9dcfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f5783824fd0eb3a484bda1931f593f"><td class="memItemLeft" align="right" valign="top">Tuple *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Dictionary.html#ga51f5783824fd0eb3a484bda1931f593f">dict_find</a> (const <a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *iter, const uint32_t key)</td></tr>
<tr class="separator:ga51f5783824fd0eb3a484bda1931f593f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga102b4f5cbdd9a40dbe8bd088d47f9ef0"><td class="memItemLeft" align="right" valign="top"><a id="ga102b4f5cbdd9a40dbe8bd088d47f9ef0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tuple</b></td></tr>
<tr class="separator:ga102b4f5cbdd9a40dbe8bd088d47f9ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga102b4f5cbdd9a40dbe8bd088d47f9ef0"><td class="memItemLeft" align="right" valign="top"><a id="ga102b4f5cbdd9a40dbe8bd088d47f9ef0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Tuple</b></td></tr>
<tr class="separator:ga102b4f5cbdd9a40dbe8bd088d47f9ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Data serialization utilities. </p>
<p>Data residing in different parts of Pebble memory (RAM) may need to be gathered and assembled into a single continuous block for transport over the network via Bluetooth. The process of gathering and assembling this continuous block of data is called serialization.</p>
<p>You use data serialization utilities, like Dictionary, Tuple and <a class="el" href="structTuplet.html">Tuplet</a> data structures and accompanying functions, to accomplish this task. No transformations are performed on the actual data, however. These Pebble utilities simply help assemble the data into one continuous buffer according to a specific format.</p>
<p><a class="el" href="group__AppMessage.html">AppMessage</a> uses these utilities&ndash;in particular, Dictionary&ndash;to send information between mobile and Pebble watchapps.</p>
<h3>Writing key/value pairs</h3>
<p>To write two key/value pairs, without using Tuplets, you would do this: </p><div class="fragment"><div class="line"><span class="comment">// Byte array + key:</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t SOME_DATA_KEY = 0xb00bf00b;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// CString + key:</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t SOME_STRING_KEY = 0xabbababe;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span> = <span class="stringliteral">&quot;Hello World&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Calculate the buffer size that is needed for the final Dictionary:</span></div>
<div class="line"><span class="keyword">const</span> uint8_t key_count = 2;</div>
<div class="line"><span class="keyword">const</span> uint32_t size = <a class="code" href="group__Dictionary.html#ga0551d069624fb5bfc066fecfa4153bde">dict_calc_buffer_size</a>(key_count, <span class="keyword">sizeof</span>(data),</div>
<div class="line">                                            strlen(<span class="keywordtype">string</span>) + 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stack-allocated buffer in which to create the Dictionary:</span></div>
<div class="line">uint8_t buffer[size];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterator variable, keeps the state of the creation serialization process:</span></div>
<div class="line"><a class="code" href="structDictionaryIterator.html">DictionaryIterator</a> iter;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Begin:</span></div>
<div class="line"><a class="code" href="group__Dictionary.html#ga9ec44fce51a2ce464a954b2bdd240ded">dict_write_begin</a>(&amp;iter, buffer, <span class="keyword">sizeof</span>(buffer));</div>
<div class="line"><span class="comment">// Write the Data:</span></div>
<div class="line"><a class="code" href="group__Dictionary.html#ga30091feef740732d5d6bc3cf2312642a">dict_write_data</a>(&amp;iter, SOME_DATA_KEY, data, <span class="keyword">sizeof</span>(data));</div>
<div class="line"><span class="comment">// Write the CString:</span></div>
<div class="line"><a class="code" href="group__Dictionary.html#ga015dfe89d0ee2f8b4e16ddda21bcf556">dict_write_cstring</a>(&amp;iter, SOME_STRING_KEY, <span class="keywordtype">string</span>);</div>
<div class="line"><span class="comment">// End:</span></div>
<div class="line"><span class="keyword">const</span> uint32_t final_size = <a class="code" href="group__Dictionary.html#ga3eb27175dd477e85ddd6add9bd1f8989">dict_write_end</a>(&amp;iter);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// buffer now contains the serialized information</span></div>
</div><!-- fragment --><h3>Reading key/value pairs</h3>
<p>To iterate over the key/value pairs in the dictionary that was created in the previous example code, you would do this:</p>
<div class="fragment"><div class="line">Tuple *tuple = <a class="code" href="group__Dictionary.html#ga0d5d65d21509a42a3113f8b09768d8c5">dict_read_begin_from_buffer</a>(&amp;iter, buffer, final_size);</div>
<div class="line"><span class="keywordflow">while</span> (tuple) {</div>
<div class="line">  <span class="keywordflow">switch</span> (tuple-&gt;key) {</div>
<div class="line">    <span class="keywordflow">case</span> SOME_DATA_KEY:</div>
<div class="line">      foo(tuple-&gt;value-&gt;data, tuple-&gt;length);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> SOME_STRING_KEY:</div>
<div class="line">      bar(tuple-&gt;value-&gt;cstring);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">  tuple = <a class="code" href="group__Dictionary.html#ga0494e17cb2cb325f10d7c3172ecd676b">dict_read_next</a>(&amp;iter);</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Tuple and <a class="el" href="structTuplet.html">Tuplet</a> data structures</h3>
<p>To understand the difference between Tuple and <a class="el" href="structTuplet.html">Tuplet</a> data structures: Tuple is the header for a serialized key/value pair, while <a class="el" href="structTuplet.html">Tuplet</a> is a helper data structure that references the value you want to serialize. This data structure exists to make the creation of a Dictionary easier to write. Use this mnemonic to remember the difference: TupleT(emplate), the <a class="el" href="structTuplet.html">Tuplet</a> being a template to create a Dictionary with Tuple structures.</p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="structTuplet.html">Tuplet</a> pairs[] = {</div>
<div class="line">  <a class="code" href="group__Dictionary.html#ga152caed0a3d5db76c063b69a01157e57">TupletInteger</a>(WEATHER_ICON_KEY, (uint8_t) 1),</div>
<div class="line">  <a class="code" href="group__Dictionary.html#ga6bc99ab1d451b29385733bb92f3c937a">TupletCString</a>(WEATHER_TEMPERATURE_KEY, <span class="stringliteral">&quot;1234 Fahrenheit&quot;</span>),</div>
<div class="line">};</div>
<div class="line">uint8_t buffer[256];</div>
<div class="line">uint32_t size = <span class="keyword">sizeof</span>(buffer);</div>
<div class="line"><a class="code" href="group__Dictionary.html#gaeaaca187fe71e6d2dd8a4eb4deec2069">dict_serialize_tuplets_to_buffer</a>(pairs, ARRAY_LENGTH(pairs), buffer, &amp;size);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// buffer now contains the serialized information</span></div>
</div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8d30623394e3c7e368ea9403412e9c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d30623394e3c7e368ea9403412e9c79">&#9670;&nbsp;</a></span>TupletBytes <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TupletBytes</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a>, .key = _key, .bytes = { .data = _data, .length = _length }})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to create a <a class="el" href="structTuplet.html">Tuplet</a> with a byte array value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_key</td><td>The key </td></tr>
    <tr><td class="paramname">_data</td><td>Pointer to the bytes </td></tr>
    <tr><td class="paramname">_length</td><td>Length of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d30623394e3c7e368ea9403412e9c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d30623394e3c7e368ea9403412e9c79">&#9670;&nbsp;</a></span>TupletBytes <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TupletBytes</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7">TUPLE_BYTE_ARRAY</a>, .key = _key, .bytes = { .data = _data, .length = _length }})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to create a <a class="el" href="structTuplet.html">Tuplet</a> with a byte array value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_key</td><td>The key </td></tr>
    <tr><td class="paramname">_data</td><td>Pointer to the bytes </td></tr>
    <tr><td class="paramname">_length</td><td>Length of the buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bc99ab1d451b29385733bb92f3c937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc99ab1d451b29385733bb92f3c937a">&#9670;&nbsp;</a></span>TupletCString <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TupletCString</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_cstring&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a>, .key = _key, .cstring = { .data = _cstring, .length = _cstring ? strlen(_cstring) + 1 : 0 }})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to create a <a class="el" href="structTuplet.html">Tuplet</a> with a c-string value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_key</td><td>The key </td></tr>
    <tr><td class="paramname">_cstring</td><td>The c-string value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bc99ab1d451b29385733bb92f3c937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc99ab1d451b29385733bb92f3c937a">&#9670;&nbsp;</a></span>TupletCString <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TupletCString</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_cstring&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab">TUPLE_CSTRING</a>, .key = _key, .cstring = { .data = _cstring, .length = _cstring ? strlen(_cstring) + 1 : 0 }})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to create a <a class="el" href="structTuplet.html">Tuplet</a> with a c-string value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_key</td><td>The key </td></tr>
    <tr><td class="paramname">_cstring</td><td>The c-string value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga152caed0a3d5db76c063b69a01157e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152caed0a3d5db76c063b69a01157e57">&#9670;&nbsp;</a></span>TupletInteger <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TupletInteger</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_integer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = IS_SIGNED(_integer) ? <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> : <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a>, .key = _key, .integer = { .storage = _integer, .width = sizeof(_integer) }})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to create a <a class="el" href="structTuplet.html">Tuplet</a> with an integer value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_key</td><td>The key </td></tr>
    <tr><td class="paramname">_integer</td><td>The integer value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga152caed0a3d5db76c063b69a01157e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152caed0a3d5db76c063b69a01157e57">&#9670;&nbsp;</a></span>TupletInteger <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TupletInteger</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_integer&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((const <a class="el" href="structTuplet.html">Tuplet</a>) { .type = IS_SIGNED(_integer) ? <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4">TUPLE_INT</a> : <a class="el" href="group__Dictionary.html#ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe">TUPLE_UINT</a>, .key = _key, .integer = { .storage = _integer, .width = sizeof(_integer) }})</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to create a <a class="el" href="structTuplet.html">Tuplet</a> with an integer value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_key</td><td>The key </td></tr>
    <tr><td class="paramname">_integer</td><td>The integer value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9dcb8cc0ffca04141354048a6e3bd379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dcb8cc0ffca04141354048a6e3bd379">&#9670;&nbsp;</a></span>DictionaryKeyUpdatedCallback <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DictionaryKeyUpdatedCallback) (const uint32_t key, const Tuple *new_tuple, const Tuple *old_tuple, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the callback used in <a class="el" href="group__Dictionary.html#ga8ab5934dba34043d2f3319e9ff9dcfc1">dict_merge()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key that is being updated. </td></tr>
    <tr><td class="paramname">new_tuple</td><td>The new tuple. The tuple points to the actual, updated destination dictionary or NULL_TUPLE in case there was an error (e.g. backing buffer was too small). Therefore the Tuple can be used after the callback returns, until the destination dictionary storage is free'd (by the application itself). </td></tr>
    <tr><td class="paramname">old_tuple</td><td>The values that will be replaced with <code>new_tuple</code>. The key, value and type will be equal to the previous tuple in the old destination dictionary, however the `old_tuple points to a stack-allocated copy of the old data. </td></tr>
    <tr><td class="paramname">context</td><td>Pointer to application specific data The storage backing <code>old_tuple</code> can only be used during the callback and will no longer be valid after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Dictionary.html#ga8ab5934dba34043d2f3319e9ff9dcfc1">dict_merge</a> </dd></dl>

</div>
</div>
<a id="ga9dcb8cc0ffca04141354048a6e3bd379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dcb8cc0ffca04141354048a6e3bd379">&#9670;&nbsp;</a></span>DictionaryKeyUpdatedCallback <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DictionaryKeyUpdatedCallback) (const uint32_t key, const Tuple *new_tuple, const Tuple *old_tuple, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the callback used in <a class="el" href="group__Dictionary.html#ga8ab5934dba34043d2f3319e9ff9dcfc1">dict_merge()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key that is being updated. </td></tr>
    <tr><td class="paramname">new_tuple</td><td>The new tuple. The tuple points to the actual, updated destination dictionary or NULL_TUPLE in case there was an error (e.g. backing buffer was too small). Therefore the Tuple can be used after the callback returns, until the destination dictionary storage is free'd (by the application itself). </td></tr>
    <tr><td class="paramname">old_tuple</td><td>The values that will be replaced with <code>new_tuple</code>. The key, value and type will be equal to the previous tuple in the old destination dictionary, however the `old_tuple points to a stack-allocated copy of the old data. </td></tr>
    <tr><td class="paramname">context</td><td>Pointer to application specific data The storage backing <code>old_tuple</code> can only be used during the callback and will no longer be valid after the callback returns. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Dictionary.html#ga8ab5934dba34043d2f3319e9ff9dcfc1">dict_merge</a> </dd></dl>

</div>
</div>
<a id="gac42a608a61e00467c9d2c98bbc512458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac42a608a61e00467c9d2c98bbc512458">&#9670;&nbsp;</a></span>DictionarySerializeCallback <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DictionarySerializeCallback) (const uint8_t *const data, const uint16_t size, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for <a class="el" href="group__Dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets()</a> utility. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data of the serialized dictionary </td></tr>
    <tr><td class="paramname">size</td><td>The size of data </td></tr>
    <tr><td class="paramname">context</td><td>The context pointer as passed in to <a class="el" href="group__Dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets</a> </dd></dl>

</div>
</div>
<a id="gac42a608a61e00467c9d2c98bbc512458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac42a608a61e00467c9d2c98bbc512458">&#9670;&nbsp;</a></span>DictionarySerializeCallback <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* DictionarySerializeCallback) (const uint8_t *const data, const uint16_t size, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for <a class="el" href="group__Dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets()</a> utility. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data of the serialized dictionary </td></tr>
    <tr><td class="paramname">size</td><td>The size of data </td></tr>
    <tr><td class="paramname">context</td><td>The context pointer as passed in to <a class="el" href="group__Dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Dictionary.html#ga6de59736dc56fcda7e4df30ba10ba0cc">dict_serialize_tuplets</a> </dd></dl>

</div>
</div>
<a id="ga257454e97afac51fdc4f2ce6c891b948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga257454e97afac51fdc4f2ce6c891b948">&#9670;&nbsp;</a></span>Tuplet <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structTuplet.html">Tuplet</a> <a class="el" href="structTuplet.html">Tuplet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-serialized, template data structure for a key/value pair. For strings and byte arrays, it only has a pointer to the actual data. For integers, it provides storage for integers up to 32-bits wide. The <a class="el" href="structTuplet.html">Tuplet</a> data structure is useful when creating dictionaries from values that are already stored in arbitrary buffers. See also Tuple, with is the header of a serialized key/value pair. </p>

</div>
</div>
<a id="ga257454e97afac51fdc4f2ce6c891b948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga257454e97afac51fdc4f2ce6c891b948">&#9670;&nbsp;</a></span>Tuplet <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structTuplet.html">Tuplet</a> <a class="el" href="structTuplet.html">Tuplet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-serialized, template data structure for a key/value pair. For strings and byte arrays, it only has a pointer to the actual data. For integers, it provides storage for integers up to 32-bits wide. The <a class="el" href="structTuplet.html">Tuplet</a> data structure is useful when creating dictionaries from values that are already stored in arbitrary buffers. See also Tuple, with is the header of a serialized key/value pair. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaafae887a6d07cde8d11885c755b55351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafae887a6d07cde8d11885c755b55351">&#9670;&nbsp;</a></span>DictionaryResult <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values for dictionary write/conversion functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6"></a>DICT_OK&#160;</td><td class="fielddoc"><p>The operation returned successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04"></a>DICT_NOT_ENOUGH_STORAGE&#160;</td><td class="fielddoc"><p>There was not enough backing storage to complete the operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2"></a>DICT_INVALID_ARGS&#160;</td><td class="fielddoc"><p>One or more arguments were invalid or uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876"></a>DICT_INTERNAL_INCONSISTENCY&#160;</td><td class="fielddoc"><p>The lengths and/or count of the dictionary its tuples are inconsistent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045"></a>DICT_MALLOC_FAILED&#160;</td><td class="fielddoc"><p>A requested operation required additional memory to be allocated, but the allocation failed, likely due to insufficient remaining heap memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6"></a>DICT_OK&#160;</td><td class="fielddoc"><p>The operation returned successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04"></a>DICT_NOT_ENOUGH_STORAGE&#160;</td><td class="fielddoc"><p>There was not enough backing storage to complete the operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2"></a>DICT_INVALID_ARGS&#160;</td><td class="fielddoc"><p>One or more arguments were invalid or uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876"></a>DICT_INTERNAL_INCONSISTENCY&#160;</td><td class="fielddoc"><p>The lengths and/or count of the dictionary its tuples are inconsistent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045"></a>DICT_MALLOC_FAILED&#160;</td><td class="fielddoc"><p>A requested operation required additional memory to be allocated, but the allocation failed, likely due to insufficient remaining heap memory. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaafae887a6d07cde8d11885c755b55351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafae887a6d07cde8d11885c755b55351">&#9670;&nbsp;</a></span>DictionaryResult <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values for dictionary write/conversion functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6"></a>DICT_OK&#160;</td><td class="fielddoc"><p>The operation returned successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04"></a>DICT_NOT_ENOUGH_STORAGE&#160;</td><td class="fielddoc"><p>There was not enough backing storage to complete the operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2"></a>DICT_INVALID_ARGS&#160;</td><td class="fielddoc"><p>One or more arguments were invalid or uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876"></a>DICT_INTERNAL_INCONSISTENCY&#160;</td><td class="fielddoc"><p>The lengths and/or count of the dictionary its tuples are inconsistent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045"></a>DICT_MALLOC_FAILED&#160;</td><td class="fielddoc"><p>A requested operation required additional memory to be allocated, but the allocation failed, likely due to insufficient remaining heap memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6"></a>DICT_OK&#160;</td><td class="fielddoc"><p>The operation returned successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04"></a>DICT_NOT_ENOUGH_STORAGE&#160;</td><td class="fielddoc"><p>There was not enough backing storage to complete the operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2"></a>DICT_INVALID_ARGS&#160;</td><td class="fielddoc"><p>One or more arguments were invalid or uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351ad1c1a2b4398b21aca5d171b47f1b6876"></a>DICT_INTERNAL_INCONSISTENCY&#160;</td><td class="fielddoc"><p>The lengths and/or count of the dictionary its tuples are inconsistent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaafae887a6d07cde8d11885c755b55351a613e308b84e2711144a049c512393045"></a>DICT_MALLOC_FAILED&#160;</td><td class="fielddoc"><p>A requested operation required additional memory to be allocated, but the allocation failed, likely due to insufficient remaining heap memory. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf164f32d9bda6829f1738ef3fb2c6670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf164f32d9bda6829f1738ef3fb2c6670">&#9670;&nbsp;</a></span>TupleType <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">TupleType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values representing the type of data that the <code>value</code> field of a Tuple contains. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7"></a>TUPLE_BYTE_ARRAY&#160;</td><td class="fielddoc"><p>The value is an array of bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab"></a>TUPLE_CSTRING&#160;</td><td class="fielddoc"><p>The value is a zero-terminated, UTF-8 C-string. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe"></a>TUPLE_UINT&#160;</td><td class="fielddoc"><p>The value is an unsigned integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4"></a>TUPLE_INT&#160;</td><td class="fielddoc"><p>The value is a signed integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7"></a>TUPLE_BYTE_ARRAY&#160;</td><td class="fielddoc"><p>The value is an array of bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab"></a>TUPLE_CSTRING&#160;</td><td class="fielddoc"><p>The value is a zero-terminated, UTF-8 C-string. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe"></a>TUPLE_UINT&#160;</td><td class="fielddoc"><p>The value is an unsigned integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4"></a>TUPLE_INT&#160;</td><td class="fielddoc"><p>The value is a signed integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf164f32d9bda6829f1738ef3fb2c6670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf164f32d9bda6829f1738ef3fb2c6670">&#9670;&nbsp;</a></span>TupleType <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Dictionary.html#gaf164f32d9bda6829f1738ef3fb2c6670">TupleType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values representing the type of data that the <code>value</code> field of a Tuple contains. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7"></a>TUPLE_BYTE_ARRAY&#160;</td><td class="fielddoc"><p>The value is an array of bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab"></a>TUPLE_CSTRING&#160;</td><td class="fielddoc"><p>The value is a zero-terminated, UTF-8 C-string. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe"></a>TUPLE_UINT&#160;</td><td class="fielddoc"><p>The value is an unsigned integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4"></a>TUPLE_INT&#160;</td><td class="fielddoc"><p>The value is a signed integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad852031b350c69166303a05dbe294ec7"></a>TUPLE_BYTE_ARRAY&#160;</td><td class="fielddoc"><p>The value is an array of bytes. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a73c9d3384801aec20d36c732d9218dab"></a>TUPLE_CSTRING&#160;</td><td class="fielddoc"><p>The value is a zero-terminated, UTF-8 C-string. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670a6802e5d267fdda619ffb13fc80d873fe"></a>TUPLE_UINT&#160;</td><td class="fielddoc"><p>The value is an unsigned integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf164f32d9bda6829f1738ef3fb2c6670ad691daf1df77095c1e19fe30b6cea5b4"></a>TUPLE_INT&#160;</td><td class="fielddoc"><p>The value is a signed integer. The tuple's <code>.length</code> field is used to determine the size of the integer (1, 2, or 4 bytes). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0551d069624fb5bfc066fecfa4153bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0551d069624fb5bfc066fecfa4153bde">&#9670;&nbsp;</a></span>dict_calc_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dict_calc_buffer_size </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuple_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of bytes that a dictionary will occupy, given one or more value lengths that need to be stored in the dictionary. </p><dl class="section note"><dt>Note</dt><dd>The formula to calculate the size of a Dictionary in bytes is: <pre>1 + (n * 7) + D1 + ... + Dn</pre> Where <code>n</code> is the number of Tuples in the Dictionary and <code>Dx</code> are the sizes of the values in the Tuples. The size of the Dictionary header is 1 byte. The size of the header for each Tuple is 7 bytes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_count</td><td>The total number of key/value pairs in the dictionary. </td></tr>
    <tr><td class="paramname">...</td><td>The sizes of each of the values that need to be stored in the dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes of storage needed. </dd></dl>

</div>
</div>
<a id="gad31424a83643adbfd9e84c4bd37e4627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad31424a83643adbfd9e84c4bd37e4627">&#9670;&nbsp;</a></span>dict_calc_buffer_size_from_tuplets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dict_calc_buffer_size_from_tuplets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTuplet.html">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of bytes that a dictionary will occupy, given one or more Tuplets that need to be stored in the dictionary. </p><dl class="section note"><dt>Note</dt><dd>See <a class="el" href="group__Dictionary.html#ga0551d069624fb5bfc066fecfa4153bde">dict_calc_buffer_size()</a> for the formula for the calculation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuplets</td><td>An array of Tuplets that need to be stored in the dictionary. </td></tr>
    <tr><td class="paramname">tuplets_count</td><td>The total number of Tuplets that follow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes of storage needed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTuplet.html">Tuplet</a> </dd></dl>

</div>
</div>
<a id="ga51f5783824fd0eb3a484bda1931f593f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f5783824fd0eb3a484bda1931f593f">&#9670;&nbsp;</a></span>dict_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tuple * dict_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to find a Tuple with specified key in a dictionary </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>Iterator to the dictionary to search in. </td></tr>
    <tr><td class="paramname">key</td><td>The key for which to find a Tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a found Tuple, or NULL if there was no Tuple with the specified key. </dd></dl>

</div>
</div>
<a id="ga8ab5934dba34043d2f3319e9ff9dcfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ab5934dba34043d2f3319e9ff9dcfc1">&#9670;&nbsp;</a></span>dict_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dest_max_size_in_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>update_existing_keys_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Dictionary.html#ga9dcb8cc0ffca04141354048a6e3bd379">DictionaryKeyUpdatedCallback</a>&#160;</td>
          <td class="paramname"><em>key_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges entries from another "source" dictionary into a "destination" dictionary. All Tuples from the source are written into the destination dictionary, while updating the exsting Tuples with matching keys. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">dest</td><td>The destination dictionary to update </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest_max_size_in_out</td><td>In: the maximum size of buffer backing <code>dest</code>. Out: the final size of the updated dictionary. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">source</td><td>The source dictionary of which its Tuples will be used to update dest. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">update_existing_keys_only</td><td>Specify True if only the existing keys in <code>dest</code> should be updated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_callback</td><td>The callback that will be called for each Tuple in the merged destination dictionary. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>Pointer to app specific data that will get passed in when <code>update_key_callback</code> is called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> </dd></dl>

</div>
</div>
<a id="ga0d5d65d21509a42a3113f8b09768d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d5d65d21509a42a3113f8b09768d8c5">&#9670;&nbsp;</a></span>dict_read_begin_from_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tuple * dict_read_begin_from_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the dictionary iterator with a given buffer and size, in preparation of reading key/value tuples. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">buffer</td><td>The storage of the dictionary </td></tr>
    <tr><td class="paramname">size</td><td>The storage size of the dictionary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </dd></dl>

</div>
</div>
<a id="gac1443377d1e746e315fc943016885cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1443377d1e746e315fc943016885cf2">&#9670;&nbsp;</a></span>dict_read_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tuple * dict_read_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the iterator back to the same state as a call to <a class="el" href="group__Dictionary.html#ga0d5d65d21509a42a3113f8b09768d8c5">dict_read_begin_from_buffer()</a> would do. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first tuple in the dictionary, or NULL in case the dictionary was empty or if there was a parsing error. </dd></dl>

</div>
</div>
<a id="ga0494e17cb2cb325f10d7c3172ecd676b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0494e17cb2cb325f10d7c3172ecd676b">&#9670;&nbsp;</a></span>dict_read_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tuple * dict_read_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Progresses the iterator to the next key/value pair. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next tuple in the dictionary, or NULL in case the end has been reached or if there was a parsing error. </dd></dl>

</div>
</div>
<a id="ga6de59736dc56fcda7e4df30ba10ba0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6de59736dc56fcda7e4df30ba10ba0cc">&#9670;&nbsp;</a></span>dict_serialize_tuplets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_serialize_tuplets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Dictionary.html#gac42a608a61e00467c9d2c98bbc512458">DictionarySerializeCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTuplet.html">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function that takes a list of Tuplets from which a dictionary will be serialized, ready to transmit or store. </p><dl class="section note"><dt>Note</dt><dd>The callback will be called before the function returns, so the data that that <code>context</code> points to, can be stack allocated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback that will be called with the serialized data of the generated dictionary. </td></tr>
    <tr><td class="paramname">context</td><td>Pointer to any application specific data that gets passed into the callback. </td></tr>
    <tr><td class="paramname">tuplets</td><td>An array of Tuplets that need to be serialized into the dictionary. </td></tr>
    <tr><td class="paramname">tuplets_count</td><td>The number of tuplets that follow. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a id="gaeaaca187fe71e6d2dd8a4eb4deec2069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaaca187fe71e6d2dd8a4eb4deec2069">&#9670;&nbsp;</a></span>dict_serialize_tuplets_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_serialize_tuplets_to_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTuplet.html">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size_in_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function that takes an array of Tuplets and serializes them into a dictionary with a given buffer and size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">tuplets</td><td>The array of tuplets </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuplets_count</td><td>The number of tuplets in the array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>The buffer in which to write the serialized dictionary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_in_out</td><td>The available buffer size in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_in_out</td><td>The number of bytes written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a id="ga93526111e666de9fdca7276f6ca73c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93526111e666de9fdca7276f6ca73c5d">&#9670;&nbsp;</a></span>dict_serialize_tuplets_to_buffer_with_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_serialize_tuplets_to_buffer_with_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTuplet.html">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>tuplets_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size_in_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes an array of Tuplets into a dictionary with a given buffer and size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuplets</td><td>The array of tuplets </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tuplets_count</td><td>The number of tuplets in the array </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">buffer</td><td>The buffer in which to write the serialized dictionary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size_in_out</td><td>The available buffer size in bytes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size_in_out</td><td>The number of bytes written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a id="gaa7fbb0db218e7e6f59eccfa2650fd645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7fbb0db218e7e6f59eccfa2650fd645">&#9670;&nbsp;</a></span>dict_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dict_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the size of data that has been written to the dictionary. AKA, the "dictionary size". Note that this is most likely different than the size of the backing storage/backing buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes which have been written to the dictionary. </dd></dl>

</div>
</div>
<a id="ga9ec44fce51a2ce464a954b2bdd240ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec44fce51a2ce464a954b2bdd240ded">&#9670;&nbsp;</a></span>dict_write_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the dictionary iterator with a given buffer and size, resets and empties it, in preparation of writing key/value tuples. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">buffer</td><td>The storage of the dictionary </td></tr>
    <tr><td class="paramname">size</td><td>The storage size of the dictionary </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Dictionary.html#ga0551d069624fb5bfc066fecfa4153bde">dict_calc_buffer_size</a> </dd>
<dd>
<a class="el" href="group__Dictionary.html#ga3eb27175dd477e85ddd6add9bd1f8989">dict_write_end</a> </dd></dl>

</div>
</div>
<a id="ga015dfe89d0ee2f8b4e16ddda21bcf556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga015dfe89d0ee2f8b4e16ddda21bcf556">&#9670;&nbsp;</a></span>dict_write_cstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_cstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>cstring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a key with a C string value pair to the dictionary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">cstring</td><td>Pointer to the zero-terminated C string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The string will be copied into the backing storage of the dictionary. </dd>
<dd>
There is <em>no</em> checking for duplicate keys. </dd></dl>

</div>
</div>
<a id="ga30091feef740732d5d6bc3cf2312642a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30091feef740732d5d6bc3cf2312642a">&#9670;&nbsp;</a></span>dict_write_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a key with a byte array value pair to the dictionary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the byte array </td></tr>
    <tr><td class="paramname">size</td><td>Length of the byte array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The data will be copied into the backing storage of the dictionary. </dd>
<dd>
There is <em>no</em> checking for duplicate keys. </dd></dl>

</div>
</div>
<a id="ga3eb27175dd477e85ddd6add9bd1f8989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb27175dd477e85ddd6add9bd1f8989">&#9670;&nbsp;</a></span>dict_write_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t dict_write_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>End a series of writing operations to a dictionary. This must be called before reading back from the dictionary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the finalized dictionary, or 0 if the parameters were invalid. </dd></dl>

</div>
</div>
<a id="ga8c4675ccaca8f466f87efb43ae2b2da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c4675ccaca8f466f87efb43ae2b2da5">&#9670;&nbsp;</a></span>dict_write_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>width_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>is_signed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a key with an integer value pair to the dictionary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">integer</td><td>Pointer to the integer value </td></tr>
    <tr><td class="paramname">width_bytes</td><td>The width of the integer value </td></tr>
    <tr><td class="paramname">is_signed</td><td>Whether the integer's type is signed or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is <em>no</em> checking for duplicate keys. <a class="el" href="group__Dictionary.html#ga8c4675ccaca8f466f87efb43ae2b2da5">dict_write_int()</a> is only for serializing a single integer. width_bytes can only be 1, 2, or 4. </dd></dl>

</div>
</div>
<a id="ga5ed3421ff8e8deda77545aae7d63f191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ed3421ff8e8deda77545aae7d63f191">&#9670;&nbsp;</a></span>dict_write_tuplet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_tuplet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTuplet.html">Tuplet</a> *const&#160;</td>
          <td class="paramname"><em>tuplet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serializes a <a class="el" href="structTuplet.html">Tuplet</a> and writes the resulting Tuple into a dictionary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">tuplet</td><td>The <a class="el" href="structTuplet.html">Tuplet</a> describing the key/value pair to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>

</div>
</div>
<a id="ga8fab9c8ce0fdae44a891c6784f4d38a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fab9c8ce0fdae44a891c6784f4d38a9">&#9670;&nbsp;</a></span>dict_write_uint8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Dictionary.html#gaafae887a6d07cde8d11885c755b55351">DictionaryResult</a> dict_write_uint8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDictionaryIterator.html">DictionaryIterator</a> *&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a key with an unsigned, 8-bit integer value pair to the dictionary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The dictionary iterator </td></tr>
    <tr><td class="paramname">key</td><td>The key </td></tr>
    <tr><td class="paramname">value</td><td>The unsigned, 8-bit integer value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351af73d82390e594bfac5d10931183b27a6">DICT_OK</a>, <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a436347bb1e21285a334a96da7b9e8f04">DICT_NOT_ENOUGH_STORAGE</a> or <a class="el" href="group__Dictionary.html#ggaafae887a6d07cde8d11885c755b55351a7f135de6b3f8f23083dc99dcb49ac2a2">DICT_INVALID_ARGS</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is <em>no</em> checking for duplicate keys. </dd>
<dd>
There are counterpart functions for different signedness and widths, <code>dict_write_uint16()</code>, <code>dict_write_uint32()</code>, <code>dict_write_int8()</code>, <code>dict_write_int16()</code> and <code>dict_write_int32()</code>. The documentation is not repeated for brevity's sake. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__Dictionary_html_ga6bc99ab1d451b29385733bb92f3c937a"><div class="ttname"><a href="group__Dictionary.html#ga6bc99ab1d451b29385733bb92f3c937a">TupletCString</a></div><div class="ttdeci">#define TupletCString(_key, _cstring)</div><div class="ttdef"><b>Definition:</b> pebble.h:1872</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga0551d069624fb5bfc066fecfa4153bde"><div class="ttname"><a href="group__Dictionary.html#ga0551d069624fb5bfc066fecfa4153bde">dict_calc_buffer_size</a></div><div class="ttdeci">uint32_t dict_calc_buffer_size(const uint8_t tuple_count,...)</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga015dfe89d0ee2f8b4e16ddda21bcf556"><div class="ttname"><a href="group__Dictionary.html#ga015dfe89d0ee2f8b4e16ddda21bcf556">dict_write_cstring</a></div><div class="ttdeci">DictionaryResult dict_write_cstring(DictionaryIterator *iter, const uint32_t key, const char *const cstring)</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga152caed0a3d5db76c063b69a01157e57"><div class="ttname"><a href="group__Dictionary.html#ga152caed0a3d5db76c063b69a01157e57">TupletInteger</a></div><div class="ttdeci">#define TupletInteger(_key, _integer)</div><div class="ttdef"><b>Definition:</b> pebble.h:1878</div></div>
<div class="ttc" id="agroup__Dictionary_html_gaeaaca187fe71e6d2dd8a4eb4deec2069"><div class="ttname"><a href="group__Dictionary.html#gaeaaca187fe71e6d2dd8a4eb4deec2069">dict_serialize_tuplets_to_buffer</a></div><div class="ttdeci">DictionaryResult dict_serialize_tuplets_to_buffer(const Tuplet *const tuplets, const uint8_t tuplets_count, uint8_t *buffer, uint32_t *size_in_out)</div></div>
<div class="ttc" id="astructDictionaryIterator_html"><div class="ttname"><a href="structDictionaryIterator.html">DictionaryIterator</a></div><div class="ttdef"><b>Definition:</b> pebble.h:1705</div></div>
<div class="ttc" id="astructTuplet_html"><div class="ttname"><a href="structTuplet.html">Tuplet</a></div><div class="ttdef"><b>Definition:</b> pebble.h:1827</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga3eb27175dd477e85ddd6add9bd1f8989"><div class="ttname"><a href="group__Dictionary.html#ga3eb27175dd477e85ddd6add9bd1f8989">dict_write_end</a></div><div class="ttdeci">uint32_t dict_write_end(DictionaryIterator *iter)</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga30091feef740732d5d6bc3cf2312642a"><div class="ttname"><a href="group__Dictionary.html#ga30091feef740732d5d6bc3cf2312642a">dict_write_data</a></div><div class="ttdeci">DictionaryResult dict_write_data(DictionaryIterator *iter, const uint32_t key, const uint8_t *const data, const uint16_t size)</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga0d5d65d21509a42a3113f8b09768d8c5"><div class="ttname"><a href="group__Dictionary.html#ga0d5d65d21509a42a3113f8b09768d8c5">dict_read_begin_from_buffer</a></div><div class="ttdeci">Tuple * dict_read_begin_from_buffer(DictionaryIterator *iter, const uint8_t *const buffer, const uint16_t size)</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga9ec44fce51a2ce464a954b2bdd240ded"><div class="ttname"><a href="group__Dictionary.html#ga9ec44fce51a2ce464a954b2bdd240ded">dict_write_begin</a></div><div class="ttdeci">DictionaryResult dict_write_begin(DictionaryIterator *iter, uint8_t *const buffer, const uint16_t size)</div></div>
<div class="ttc" id="agroup__Dictionary_html_ga0494e17cb2cb325f10d7c3172ecd676b"><div class="ttname"><a href="group__Dictionary.html#ga0494e17cb2cb325f10d7c3172ecd676b">dict_read_next</a></div><div class="ttdeci">Tuple * dict_read_next(DictionaryIterator *iter)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
