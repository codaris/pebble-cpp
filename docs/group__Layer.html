<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pebble Foundation Classes: Layers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pebble Foundation Classes
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
   <div id="projectbrief">C++ for Pebble</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__Layer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Layers<div class="ingroups"><a class="el" href="group__UI.html">UI</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>User interface layers for displaying graphic components.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Layers:</div>
<div class="dyncontent">
<div class="center"><img src="group__Layer.png" border="0" usemap="#group____Layer" alt=""/></div>
<map name="group____Layer" id="group____Layer">
<area shape="rect" href="group__ScrollLayer.html" title="Layer that scrolls its contents, animated." alt="" coords="227,5,322,31"/>
<area shape="rect" href="group__ActionBarLayer.html" title="Vertical, bar&#45;shaped control widget on the right edge of the window." alt="" coords="214,55,335,80"/>
<area shape="rect" href="group__UI.html" title=" " alt="" coords="5,179,44,204"/>
<area shape="rect" title="User interface layers for displaying graphic components." alt="" coords="92,179,157,204"/>
<area shape="rect" href="group__TextLayer.html" title="Layer that displays and formats a text string." alt="" coords="232,104,317,129"/>
<area shape="rect" href="group__SimpleMenuLayer.html" title="Wrapper around MenuLayer, that uses static data to display a list menu." alt="" coords="205,153,344,179"/>
<area shape="rect" href="group__RotBitmapLayer.html" title="Layer that displays a rotated bitmap image." alt="" coords="211,203,338,228"/>
<area shape="rect" href="group__MenuLayer.html" title="Layer that displays a standard list menu. Data is provided using callbacks." alt="" coords="227,252,322,277"/>
<area shape="rect" href="group__StatusBarLayer.html" title="Layer that serves as a configurable status bar." alt="" coords="214,301,335,327"/>
<area shape="rect" href="group__BitmapLayer.html" title="Layer that displays a bitmap image." alt="" coords="222,351,327,376"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__TextLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TextLayer.html">TextLayer</a></td></tr>
<tr class="memdesc:group__TextLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that displays and formats a text string. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ScrollLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ScrollLayer.html">ScrollLayer</a></td></tr>
<tr class="memdesc:group__ScrollLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that scrolls its contents, animated. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__MenuLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MenuLayer.html">MenuLayer</a></td></tr>
<tr class="memdesc:group__MenuLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that displays a standard list menu. Data is provided using callbacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__SimpleMenuLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SimpleMenuLayer.html">SimpleMenuLayer</a></td></tr>
<tr class="memdesc:group__SimpleMenuLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="group__MenuLayer.html">MenuLayer</a>, that uses static data to display a list menu. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ActionBarLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ActionBarLayer.html">ActionBarLayer</a></td></tr>
<tr class="memdesc:group__ActionBarLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertical, bar-shaped control widget on the right edge of the window. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__StatusBarLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__StatusBarLayer.html">StatusBarLayer</a></td></tr>
<tr class="memdesc:group__StatusBarLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that serves as a configurable status bar. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__BitmapLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BitmapLayer.html">BitmapLayer</a></td></tr>
<tr class="memdesc:group__BitmapLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that displays a bitmap image. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__RotBitmapLayer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RotBitmapLayer.html">RotBitmapLayer</a></td></tr>
<tr class="memdesc:group__RotBitmapLayer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layer that displays a rotated bitmap image. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPebble_1_1Layer.html">Pebble::Layer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPebble_1_1SimpleLayer.html">Pebble::SimpleLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPebble_1_1Layer.html">Layer</a> that is automatically managed.  <a href="classPebble_1_1SimpleLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPebble_1_1CustomLayer.html">Pebble::CustomLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classPebble_1_1Layer.html">Layer</a> that is automatically managed and contains an OnUpdate callback for drawing.  <a href="classPebble_1_1CustomLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0a0b68a32dcbcdb0bdcdfc430c27732a"><td class="memItemLeft" align="right" valign="top"><a id="ga0a0b68a32dcbcdb0bdcdfc430c27732a"></a>
typedef struct Layer&#160;</td><td class="memItemRight" valign="bottom"><b>Layer</b></td></tr>
<tr class="separator:ga0a0b68a32dcbcdb0bdcdfc430c27732a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga998bcd33d985d252283ebe02400041ee"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga998bcd33d985d252283ebe02400041ee">LayerUpdateProc</a>) (struct Layer *layer, GContext *ctx)</td></tr>
<tr class="separator:ga998bcd33d985d252283ebe02400041ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa14dfd196c850be588b1ab30804690c0"><td class="memItemLeft" align="right" valign="top">Layer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gaa14dfd196c850be588b1ab30804690c0">layer_create</a> (<a class="el" href="structGRect.html">GRect</a> frame)</td></tr>
<tr class="separator:gaa14dfd196c850be588b1ab30804690c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bf50fa0daaf1e3c8ded4bc15d25f199"><td class="memItemLeft" align="right" valign="top">Layer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga5bf50fa0daaf1e3c8ded4bc15d25f199">layer_create_with_data</a> (<a class="el" href="structGRect.html">GRect</a> frame, size_t data_size)</td></tr>
<tr class="separator:ga5bf50fa0daaf1e3c8ded4bc15d25f199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab989ba5a74d4bce391bd1d343673e946"><td class="memItemLeft" align="right" valign="top"><a id="gab989ba5a74d4bce391bd1d343673e946"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gab989ba5a74d4bce391bd1d343673e946">layer_destroy</a> (Layer *layer)</td></tr>
<tr class="memdesc:gab989ba5a74d4bce391bd1d343673e946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a layer previously created by layer_create. <br /></td></tr>
<tr class="separator:gab989ba5a74d4bce391bd1d343673e946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bc895642aa02ae2d224659529382c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty</a> (Layer *layer)</td></tr>
<tr class="separator:ga00bc895642aa02ae2d224659529382c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57eddbe4fe47beefadeaf775a3c8dcaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga57eddbe4fe47beefadeaf775a3c8dcaa">layer_set_update_proc</a> (Layer *layer, <a class="el" href="group__Layer.html#ga998bcd33d985d252283ebe02400041ee">LayerUpdateProc</a> update_proc)</td></tr>
<tr class="separator:ga57eddbe4fe47beefadeaf775a3c8dcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a984a17781b97ce00ae34c437171934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame</a> (Layer *layer, <a class="el" href="structGRect.html">GRect</a> frame)</td></tr>
<tr class="separator:ga5a984a17781b97ce00ae34c437171934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ed01d3619150b87604ebaa9dc282b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga76ed01d3619150b87604ebaa9dc282b7">layer_get_frame</a> (const Layer *layer)</td></tr>
<tr class="separator:ga76ed01d3619150b87604ebaa9dc282b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a99dca38b75b52264c0734b934c865c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds</a> (Layer *layer, <a class="el" href="structGRect.html">GRect</a> bounds)</td></tr>
<tr class="separator:ga0a99dca38b75b52264c0734b934c865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e99442ac9d3af36ec7c25118360710c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga3e99442ac9d3af36ec7c25118360710c">layer_get_bounds</a> (const Layer *layer)</td></tr>
<tr class="separator:ga3e99442ac9d3af36ec7c25118360710c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bbac31d1070f43b6ecce0d07eabf2a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga1bbac31d1070f43b6ecce0d07eabf2a2">layer_get_unobstructed_bounds</a> (const Layer *layer)</td></tr>
<tr class="separator:ga1bbac31d1070f43b6ecce0d07eabf2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab09fa69c5ba3a57bcfd59184003ece3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGPoint.html">GPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gab09fa69c5ba3a57bcfd59184003ece3e">layer_convert_point_to_screen</a> (const Layer *layer, <a class="el" href="structGPoint.html">GPoint</a> point)</td></tr>
<tr class="separator:gab09fa69c5ba3a57bcfd59184003ece3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30f05eabe6c17e81840a6daa50984135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga30f05eabe6c17e81840a6daa50984135">layer_convert_rect_to_screen</a> (const Layer *layer, <a class="el" href="structGRect.html">GRect</a> rect)</td></tr>
<tr class="separator:ga30f05eabe6c17e81840a6daa50984135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9f13c7bbffb949929d7dfe64ba44915"><td class="memItemLeft" align="right" valign="top">struct Window *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gab9f13c7bbffb949929d7dfe64ba44915">layer_get_window</a> (const Layer *layer)</td></tr>
<tr class="separator:gab9f13c7bbffb949929d7dfe64ba44915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15574128ca92653c64d164f6f13e2361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga15574128ca92653c64d164f6f13e2361">layer_remove_from_parent</a> (Layer *child)</td></tr>
<tr class="separator:ga15574128ca92653c64d164f6f13e2361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20bc62c736890f73edd0a4381219950f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga20bc62c736890f73edd0a4381219950f">layer_remove_child_layers</a> (Layer *parent)</td></tr>
<tr class="separator:ga20bc62c736890f73edd0a4381219950f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga282c3ba9878e23bfa19033a9487fdac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga282c3ba9878e23bfa19033a9487fdac1">layer_add_child</a> (Layer *parent, Layer *child)</td></tr>
<tr class="separator:ga282c3ba9878e23bfa19033a9487fdac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf838c6113463f2924f50be98e15231e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gaf838c6113463f2924f50be98e15231e2">layer_insert_below_sibling</a> (Layer *layer_to_insert, Layer *below_sibling_layer)</td></tr>
<tr class="separator:gaf838c6113463f2924f50be98e15231e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad290a2abb7f0a37516bb7a45f4157db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gaad290a2abb7f0a37516bb7a45f4157db">layer_insert_above_sibling</a> (Layer *layer_to_insert, Layer *above_sibling_layer)</td></tr>
<tr class="separator:gaad290a2abb7f0a37516bb7a45f4157db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac267ce4cc84b0f39297b56edf5ca4b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gac267ce4cc84b0f39297b56edf5ca4b48">layer_set_hidden</a> (Layer *layer, bool hidden)</td></tr>
<tr class="separator:gac267ce4cc84b0f39297b56edf5ca4b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4eb514c69ad32fe5cc0f8b3ab9b9b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga2b4eb514c69ad32fe5cc0f8b3ab9b9b6">layer_get_hidden</a> (const Layer *layer)</td></tr>
<tr class="separator:ga2b4eb514c69ad32fe5cc0f8b3ab9b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e7f5b5a70fceadc6245974306b11025"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga0e7f5b5a70fceadc6245974306b11025">layer_set_clips</a> (Layer *layer, bool clips)</td></tr>
<tr class="separator:ga0e7f5b5a70fceadc6245974306b11025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga459ca188ae94ee1cd59e691e5fcefaec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#ga459ca188ae94ee1cd59e691e5fcefaec">layer_get_clips</a> (const Layer *layer)</td></tr>
<tr class="separator:ga459ca188ae94ee1cd59e691e5fcefaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd3dcaaa0f8b4bcae09ffcde21e3d13"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Layer.html#gabcd3dcaaa0f8b4bcae09ffcde21e3d13">layer_get_data</a> (const Layer *layer)</td></tr>
<tr class="separator:gabcd3dcaaa0f8b4bcae09ffcde21e3d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>User interface layers for displaying graphic components. </p>
<p>Layers are objects that can be displayed on a Pebble watchapp window, enabling users to see visual objects, like text or images. Each layer stores the information about its state necessary to draw or redraw the object that it represents and uses graphics routines along with this state to draw itself when asked. Layers can be used to display various graphics.</p>
<p>Layers are the basic building blocks for your application UI. Layers can be nested inside each other. Every window has a root layer which is always the topmost layer. You provide a function that is called to draw the content of the layer when needed; or you can use standard layers that are provided by the system, such as text layer, image layer, menu layer, action bar layer, and so on.</p>
<p>The Pebble layer hierarchy is the list of things that need to be drawn to the screen. Multiple layers can be arranged into a hierarchy. This enables ordering (front to back), layout and hierarchy. Through relative positioning, visual objects that are grouped together by adding them into the same layer can be moved all at once. This means that the child layers will move accordingly. If a parent layer has clipping enabled, all the children will be clipped to the frame of the parent.</p>
<p>Pebble OS provides convenience layers with built-in logic for displaying different graphic components, like text and bitmap layers.</p>
<p>Refer to the  (chapter "Layers") for a conceptual overview of Layers and relevant code examples.</p>
<p>Layers are objects that can be displayed on a Pebble watchapp window, enabling users to see visual objects, like text or images. Each layer stores the information about its state necessary to draw or redraw the object that it represents and uses graphics routines along with this state to draw itself when asked. Layers can be used to display various graphics.</p>
<p>Layers are the basic building blocks for your application UI. Layers can be nested inside each other. Every window has a root layer which is always the topmost layer. You provide a function that is called to draw the content of the layer when needed; or you can use standard layers that are provided by the system, such as text layer, image layer, menu layer, action bar layer, and so on.</p>
<p>The Pebble layer hierarchy is the list of things that need to be drawn to the screen. Multiple layers can be arranged into a hierarchy. This enables ordering (front to back), layout and hierarchy. Through relative positioning, visual objects that are grouped together by adding them into the same layer can be moved all at once. This means that the child layers will move accordingly. If a parent layer has clipping enabled, all the children will be clipped to the frame of the parent.</p>
<p>Pebble OS provides convenience layers with built-in logic for displaying different graphic components, like text and bitmap layers.</p>
<p>Refer to the  (chapter "Layers") for a conceptual overview of Layers and relevant code examples.</p>
<p>The Modules listed here contain what can be thought of conceptually as subclasses of <a class="el" href="classPebble_1_1Layer.html">Layer</a>. The listed types can be safely type-casted to <code><a class="el" href="classPebble_1_1Layer.html">Layer</a></code> (or <code><a class="el" href="classPebble_1_1Layer.html">Layer</a> *</code> in case of a pointer). The <code>layer_...</code> functions can then be used with the data structures of these subclasses. <br  />
For example, the following is legal: </p><div class="fragment"><div class="line">TextLayer *text_layer;</div>
<div class="line">...</div>
<div class="line">layer_set_hidden((Layer *)text_layer, <span class="keyword">true</span>);</div>
</div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="ga998bcd33d985d252283ebe02400041ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga998bcd33d985d252283ebe02400041ee">&#9670;&nbsp;</a></span>LayerUpdateProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* LayerUpdateProc) (struct Layer *layer, GContext *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function signature for a Layer's render callback (the name of the type is derived from the words 'update procedure'). The system will call the <code>.update_proc</code> callback whenever the Layer needs to be rendered. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer that needs to be rendered </td></tr>
    <tr><td class="paramname">ctx</td><td>The destination graphics context to draw into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Graphics.html">Graphics</a> </dd>
<dd>
<a class="el" href="group__Layer.html#ga57eddbe4fe47beefadeaf775a3c8dcaa">layer_set_update_proc()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga282c3ba9878e23bfa19033a9487fdac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282c3ba9878e23bfa19033a9487fdac1">&#9670;&nbsp;</a></span>layer_add_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_add_child </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the child layer to a given parent layer, making it appear in front of its parent and in front of any existing child layers of the parent. If the child layer was already part of a layer hierarchy, it will be removed from its old parent first. If added successfully, the parent (and children) will be marked dirty automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The layer to which to add the child layer </td></tr>
    <tr><td class="paramname">child</td><td>The layer to add to the parent layer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab09fa69c5ba3a57bcfd59184003ece3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab09fa69c5ba3a57bcfd59184003ece3e">&#9670;&nbsp;</a></span>layer_convert_point_to_screen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGPoint.html">GPoint</a> layer_convert_point_to_screen </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGPoint.html">GPoint</a>&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a point from the layer's local coordinate system to screen coordinates. </p><dl class="section note"><dt>Note</dt><dd>If the layer isn't part of the view hierarchy the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The view whose coordinate system will be used to convert the value to the screen. </td></tr>
    <tr><td class="paramname">point</td><td>A point specified in the local coordinate system (bounds) of the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point converted to the coordinate system of the screen. </dd></dl>

</div>
</div>
<a id="ga30f05eabe6c17e81840a6daa50984135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30f05eabe6c17e81840a6daa50984135">&#9670;&nbsp;</a></span>layer_convert_rect_to_screen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGRect.html">GRect</a> layer_convert_rect_to_screen </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a rectangle from the layer's local coordinate system to screen coordinates. </p><dl class="section note"><dt>Note</dt><dd>If the layer isn't part of the view hierarchy the result is undefined. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The view whose coordinate system will be used to convert the value to the screen. </td></tr>
    <tr><td class="paramname">rect</td><td>A rectangle specified in the local coordinate system (bounds) of the layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rectangle converted to the coordinate system of the screen. </dd></dl>

</div>
</div>
<a id="gaa14dfd196c850be588b1ab30804690c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa14dfd196c850be588b1ab30804690c0">&#9670;&nbsp;</a></span>layer_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Layer* layer_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a layer on the heap and sets its frame and bounds. Default values:</p><ul>
<li><code>bounds</code> : origin (0, 0) and a size equal to the frame that is passed in.</li>
<li><code>clips</code> : <code>true</code></li>
<li><code>hidden</code> : <code>false</code></li>
<li><code>update_proc</code> : <code>NULL</code> (draws nothing) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame at which the layer should be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame()</a> </dd>
<dd>
<a class="el" href="group__Layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer. <code>NULL</code> if the layer could not be created </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ga5bf50fa0daaf1e3c8ded4bc15d25f199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bf50fa0daaf1e3c8ded4bc15d25f199">&#9670;&nbsp;</a></span>layer_create_with_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Layer* layer_create_with_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a layer on the heap with extra space for callback data, and set its frame andbounds. Default values:</p><ul>
<li><code>bounds</code> : origin (0, 0) and a size equal to the frame that is passed in.</li>
<li><code>clips</code> : <code>true</code></li>
<li><code>hidden</code> : <code>false</code></li>
<li><code>update_proc</code> : <code>NULL</code> (draws nothing) <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The frame at which the layer should be initialized. </td></tr>
    <tr><td class="paramname">data_size</td><td>The size (in bytes) of memory to allocate for callback data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Layer.html#gaa14dfd196c850be588b1ab30804690c0">layer_create()</a> </dd>
<dd>
<a class="el" href="group__Layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame()</a> </dd>
<dd>
<a class="el" href="group__Layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the layer. <code>NULL</code> if the layer could not be created </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ga3e99442ac9d3af36ec7c25118360710c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e99442ac9d3af36ec7c25118360710c">&#9670;&nbsp;</a></span>layer_get_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGRect.html">GRect</a> layer_get_bounds </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the bounds of the layer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bounds of the layer </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds</a> </dd></dl>

</div>
</div>
<a id="ga459ca188ae94ee1cd59e691e5fcefaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga459ca188ae94ee1cd59e691e5fcefaec">&#9670;&nbsp;</a></span>layer_get_clips()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool layer_get_clips </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets whether clipping is enabled for the layer. If enabled, whatever the layer <em>and its children</em> will draw using their <code>.update_proc</code> callbacks, will be clipped by the this layer's frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the clipping property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if clipping is enabled for the layer, false if clipping is not enabled for the layer. </dd></dl>

</div>
</div>
<a id="gabcd3dcaaa0f8b4bcae09ffcde21e3d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd3dcaaa0f8b4bcae09ffcde21e3d13">&#9670;&nbsp;</a></span>layer_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* layer_get_data </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the data from a layer that has been created with an extra data region. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to get the data region from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the data region. </dd></dl>

</div>
</div>
<a id="ga76ed01d3619150b87604ebaa9dc282b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ed01d3619150b87604ebaa9dc282b7">&#9670;&nbsp;</a></span>layer_get_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGRect.html">GRect</a> layer_get_frame </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. If the frame has changed, <a class="el" href="group__Layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The frame of the layer </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame</a> </dd></dl>

</div>
</div>
<a id="ga2b4eb514c69ad32fe5cc0f8b3ab9b9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b4eb514c69ad32fe5cc0f8b3ab9b9b6">&#9670;&nbsp;</a></span>layer_get_hidden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool layer_get_hidden </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the visibility of the layer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the visibility </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the layer is hidden, false if it is not hidden. </dd></dl>

</div>
</div>
<a id="ga1bbac31d1070f43b6ecce0d07eabf2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bbac31d1070f43b6ecce0d07eabf2a2">&#9670;&nbsp;</a></span>layer_get_unobstructed_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGRect.html">GRect</a> layer_get_unobstructed_bounds </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the largest unobstructed bounds rectangle of a layer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the unobstructed bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unobstructed bounds of the layer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UnobstructedArea.html">UnobstructedArea</a> </dd></dl>

</div>
</div>
<a id="gab9f13c7bbffb949929d7dfe64ba44915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9f13c7bbffb949929d7dfe64ba44915">&#9670;&nbsp;</a></span>layer_get_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Window* layer_get_window </td>
          <td>(</td>
          <td class="paramtype">const Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the window that the layer is currently attached to. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to get the window </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The window that this layer is currently attached to, or <code>NULL</code> if it has not been added to a window's layer hierarchy. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Window.html#ga8a0233aa7927ebc51a0b2d8708f52fe0">window_get_root_layer()</a> </dd>
<dd>
<a class="el" href="group__Layer.html#ga282c3ba9878e23bfa19033a9487fdac1">layer_add_child()</a> </dd></dl>

</div>
</div>
<a id="gaad290a2abb7f0a37516bb7a45f4157db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad290a2abb7f0a37516bb7a45f4157db">&#9670;&nbsp;</a></span>layer_insert_above_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_insert_above_sibling </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer_to_insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>above_sibling_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the layer as a sibling in front of another layer. The above_layer has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_to_insert</td><td>The layer to insert into the hierarchy </td></tr>
    <tr><td class="paramname">above_sibling_layer</td><td>The layer that will be used as the sibling layer below which the insertion will take place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf838c6113463f2924f50be98e15231e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf838c6113463f2924f50be98e15231e2">&#9670;&nbsp;</a></span>layer_insert_below_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_insert_below_sibling </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer_to_insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>below_sibling_layer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the layer as a sibling behind another layer. If the layer to insert was already part of a layer hierarchy, it will be removed from its old parent first. The below_layer has to be a child of a parent layer, otherwise this function will be a noop. If inserted successfully, the parent (and children) will be marked dirty automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_to_insert</td><td>The layer to insert into the hierarchy </td></tr>
    <tr><td class="paramname">below_sibling_layer</td><td>The layer that will be used as the sibling layer above which the insertion will take place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga00bc895642aa02ae2d224659529382c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00bc895642aa02ae2d224659529382c8">&#9670;&nbsp;</a></span>layer_mark_dirty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_mark_dirty </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the complete layer as "dirty", awaiting to be asked by the system to redraw itself. Typically, this function is called whenever state has changed that affects what the layer is displaying.</p><ul>
<li>The layer's <code>.update_proc</code> will not be called before this function returns, but will be called asynchronously, shortly.</li>
<li>Internally, a call to this function will schedule a re-render of the window that the layer belongs to. In effect, all layers in that window's layer hierarchy will be asked to redraw.</li>
<li>If an earlier re-render request is still pending, this function is a no-op. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer to mark dirty </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ga20bc62c736890f73edd0a4381219950f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20bc62c736890f73edd0a4381219950f">&#9670;&nbsp;</a></span>layer_remove_child_layers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_remove_child_layers </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes child layers from given layer If removed successfully, the child's parent layer will be marked dirty automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The layer from which to remove all child layers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15574128ca92653c64d164f6f13e2361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15574128ca92653c64d164f6f13e2361">&#9670;&nbsp;</a></span>layer_remove_from_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_remove_from_parent </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the layer from its current parent layer If removed successfully, the child's parent layer will be marked dirty automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The layer to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a99dca38b75b52264c0734b934c865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a99dca38b75b52264c0734b934c865c">&#9670;&nbsp;</a></span>layer_set_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_bounds </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the bounds of the layer, which is it's bounding box relative to its frame. If the bounds has changed, <a class="el" href="group__Layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the bounds </td></tr>
    <tr><td class="paramname">bounds</td><td>The new bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Layer.html#ga5a984a17781b97ce00ae34c437171934">layer_set_frame()</a> </dd></dl>

</div>
</div>
<a id="ga0e7f5b5a70fceadc6245974306b11025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e7f5b5a70fceadc6245974306b11025">&#9670;&nbsp;</a></span>layer_set_clips()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_clips </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clips</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether clipping is enabled for the layer. If enabled, whatever the layer <em>and its children</em> will draw using their <code>.update_proc</code> callbacks, will be clipped by the this layer's frame. If the clipping has changed, <a class="el" href="group__Layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the clipping property </td></tr>
    <tr><td class="paramname">clips</td><td>Supply <code>true</code> to make the layer clip to its frame, or <code>false</code> to make it non-clipping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a984a17781b97ce00ae34c437171934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a984a17781b97ce00ae34c437171934">&#9670;&nbsp;</a></span>layer_set_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_frame </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the frame of the layer, which is it's bounding box relative to the coordinate system of its parent layer. The size of the layer's bounds will be extended automatically, so that the bounds cover the new frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the frame </td></tr>
    <tr><td class="paramname">frame</td><td>The new frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Layer.html#ga0a99dca38b75b52264c0734b934c865c">layer_set_bounds()</a> </dd></dl>

</div>
</div>
<a id="gac267ce4cc84b0f39297b56edf5ca4b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac267ce4cc84b0f39297b56edf5ca4b48">&#9670;&nbsp;</a></span>layer_set_hidden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_hidden </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hidden</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the visibility of the layer. If the visibility has changed, <a class="el" href="group__Layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a> will be called automatically on the parent layer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>The layer for which to set the visibility </td></tr>
    <tr><td class="paramname">hidden</td><td>Supply <code>true</code> to make the layer hidden, or <code>false</code> to make it non-hidden. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57eddbe4fe47beefadeaf775a3c8dcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57eddbe4fe47beefadeaf775a3c8dcaa">&#9670;&nbsp;</a></span>layer_set_update_proc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void layer_set_update_proc </td>
          <td>(</td>
          <td class="paramtype">Layer *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Layer.html#ga998bcd33d985d252283ebe02400041ee">LayerUpdateProc</a>&#160;</td>
          <td class="paramname"><em>update_proc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the layer's render function. The system will call the <code>update_proc</code> automatically when the layer needs to redraw itself, see also <a class="el" href="group__Layer.html#ga00bc895642aa02ae2d224659529382c8">layer_mark_dirty()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>Pointer to the layer structure. </td></tr>
    <tr><td class="paramname">update_proc</td><td>Pointer to the function that will be called when the layer needs to be rendered. Typically, one performs a series of drawing commands in the implementation of the <code>update_proc</code>, see <a class="el" href="group__Drawing.html">Drawing Primitives</a>, <a class="el" href="group__PathDrawing.html">Drawing Paths</a> and <a class="el" href="group__TextDrawing.html">Drawing Text</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
