<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Pebble Foundation Classes: Graphics Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pebble Foundation Classes
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__GraphicsTypes.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Graphics Types<div class="ingroups"><a class="el" href="group__Graphics.html">Graphics</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic graphics types (point, rect, size, color, bitmaps, etc.) and utility functions.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Graphics Types:</div>
<div class="dyncontent">
<div class="center"><img src="group__GraphicsTypes.png" border="0" usemap="#group____GraphicsTypes" alt=""/></div>
<map name="group____GraphicsTypes" id="group____GraphicsTypes">
<area shape="rect" title="Basic graphics types (point, rect, size, color, bitmaps, etc.) and utility functions." alt="" coords="132,5,252,31"/>
<area shape="rect" href="group__ColorDefinitions.html" title=" " alt="" coords="300,5,431,31"/>
<area shape="rect" href="group__Graphics.html" title=" " alt="" coords="5,5,84,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__ColorDefinitions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ColorDefinitions.html">Color Definitions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionGColor8.html">GColor8</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGPoint.html">GPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGSize.html">GSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2-dimensional size.  <a href="structGSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGRect.html">GRect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGBitmapDataRowInfo.html">GBitmapDataRowInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGEdgeInsets.html">GEdgeInsets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa7922ac35d2b7fd40547083eed4ed757"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gaa7922ac35d2b7fd40547083eed4ed757">GColorFromRGBA</a>(red,  green,  blue,  alpha)</td></tr>
<tr class="separator:gaa7922ac35d2b7fd40547083eed4ed757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5526fda29291b139ceb4c736f7aa61e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga5526fda29291b139ceb4c736f7aa61e4">GColorFromRGB</a>(red,  green,  blue)&#160;&#160;&#160;<a class="el" href="group__GraphicsTypes.html#gaa7922ac35d2b7fd40547083eed4ed757">GColorFromRGBA</a>(red, green, blue, 255)</td></tr>
<tr class="separator:ga5526fda29291b139ceb4c736f7aa61e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c778a69b007e2dd2aeb2a8253d2a3ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga3c778a69b007e2dd2aeb2a8253d2a3ad">GColorFromHEX</a>(v)&#160;&#160;&#160;<a class="el" href="group__GraphicsTypes.html#ga5526fda29291b139ceb4c736f7aa61e4">GColorFromRGB</a>(((v) &gt;&gt; 16) &amp; 0xff, ((v) &gt;&gt; 8) &amp; 0xff, ((v) &amp; 0xff))</td></tr>
<tr class="separator:ga3c778a69b007e2dd2aeb2a8253d2a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb8f728e01e63674935d7601f438841"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga8cb8f728e01e63674935d7601f438841">COLOR_FALLBACK</a>(color,  bw)&#160;&#160;&#160;(color)</td></tr>
<tr class="separator:ga8cb8f728e01e63674935d7601f438841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93dc1082b2412cc4931cc1f0e870e250"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga93dc1082b2412cc4931cc1f0e870e250">PBL_IF_RECT_ELSE</a>(if_true,  if_false)&#160;&#160;&#160;(if_true)</td></tr>
<tr class="separator:ga93dc1082b2412cc4931cc1f0e870e250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9bce65d188c24cbb92dcce0c616e2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga4f9bce65d188c24cbb92dcce0c616e2c">PBL_IF_ROUND_ELSE</a>(if_true,  if_false)&#160;&#160;&#160;(if_false)</td></tr>
<tr class="separator:ga4f9bce65d188c24cbb92dcce0c616e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ac313277ed0b20e858ba4f8f0f039d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gaa7ac313277ed0b20e858ba4f8f0f039d">PBL_IF_BW_ELSE</a>(if_true,  if_false)&#160;&#160;&#160;(if_false)</td></tr>
<tr class="separator:gaa7ac313277ed0b20e858ba4f8f0f039d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7411380c062d7024c411bdc0794206"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga5a7411380c062d7024c411bdc0794206">PBL_IF_COLOR_ELSE</a>(if_true,  if_false)&#160;&#160;&#160;(if_true)</td></tr>
<tr class="separator:ga5a7411380c062d7024c411bdc0794206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9cee451faac8ad07157b775b951699"><td class="memItemLeft" align="right" valign="top"><a id="gabf9cee451faac8ad07157b775b951699"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gabf9cee451faac8ad07157b775b951699">GPoint</a>(x,  y)&#160;&#160;&#160;((<a class="el" href="structGPoint.html">GPoint</a>){(x), (y)})</td></tr>
<tr class="memdesc:gabf9cee451faac8ad07157b775b951699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to make a <a class="el" href="structGPoint.html">GPoint</a>. <br /></td></tr>
<tr class="separator:gabf9cee451faac8ad07157b775b951699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24192f6809de17d816671a1d6a7b59b5"><td class="memItemLeft" align="right" valign="top"><a id="ga24192f6809de17d816671a1d6a7b59b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga24192f6809de17d816671a1d6a7b59b5">GPointZero</a>&#160;&#160;&#160;<a class="el" href="structGPoint.html">GPoint</a>(0, 0)</td></tr>
<tr class="memdesc:ga24192f6809de17d816671a1d6a7b59b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to make a <a class="el" href="structGPoint.html">GPoint</a> at (0, 0). <br /></td></tr>
<tr class="separator:ga24192f6809de17d816671a1d6a7b59b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71761014e71575ac39edc38709cc048b"><td class="memItemLeft" align="right" valign="top"><a id="ga71761014e71575ac39edc38709cc048b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga71761014e71575ac39edc38709cc048b">GSize</a>(w,  h)&#160;&#160;&#160;((<a class="el" href="structGSize.html">GSize</a>){(w), (h)})</td></tr>
<tr class="memdesc:ga71761014e71575ac39edc38709cc048b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to make a <a class="el" href="structGSize.html" title="Represents a 2-dimensional size.">GSize</a>. <br /></td></tr>
<tr class="separator:ga71761014e71575ac39edc38709cc048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b5e385c855d8c9ad59209816f62b808"><td class="memItemLeft" align="right" valign="top"><a id="ga7b5e385c855d8c9ad59209816f62b808"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga7b5e385c855d8c9ad59209816f62b808">GSizeZero</a>&#160;&#160;&#160;<a class="el" href="structGSize.html">GSize</a>(0, 0)</td></tr>
<tr class="memdesc:ga7b5e385c855d8c9ad59209816f62b808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to make a <a class="el" href="structGSize.html" title="Represents a 2-dimensional size.">GSize</a> of (0, 0). <br /></td></tr>
<tr class="separator:ga7b5e385c855d8c9ad59209816f62b808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a870072d31f765cbfaebe222d85f6e"><td class="memItemLeft" align="right" valign="top"><a id="ga98a870072d31f765cbfaebe222d85f6e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga98a870072d31f765cbfaebe222d85f6e">GRect</a>(x,  y,  w,  h)&#160;&#160;&#160;((<a class="el" href="structGRect.html">GRect</a>){{(x), (y)}, {(w), (h)}})</td></tr>
<tr class="memdesc:ga98a870072d31f765cbfaebe222d85f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to make a <a class="el" href="structGRect.html">GRect</a>. <br /></td></tr>
<tr class="separator:ga98a870072d31f765cbfaebe222d85f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d67ac54b909f89dfd99e52eb1a7c0bc"><td class="memItemLeft" align="right" valign="top"><a id="ga1d67ac54b909f89dfd99e52eb1a7c0bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga1d67ac54b909f89dfd99e52eb1a7c0bc">GRectZero</a>&#160;&#160;&#160;<a class="el" href="structGRect.html">GRect</a>(0, 0, 0, 0)</td></tr>
<tr class="memdesc:ga1d67ac54b909f89dfd99e52eb1a7c0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to make a <a class="el" href="structGRect.html">GRect</a> of ((0, 0), (0, 0)). <br /></td></tr>
<tr class="separator:ga1d67ac54b909f89dfd99e52eb1a7c0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace600ef49d59abf22dbaad7b5018d746"><td class="memItemLeft" align="right" valign="top"><a id="gace600ef49d59abf22dbaad7b5018d746"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gace600ef49d59abf22dbaad7b5018d746">PLAY_COUNT_INFINITE</a>&#160;&#160;&#160;UINT32_MAX</td></tr>
<tr class="memdesc:gace600ef49d59abf22dbaad7b5018d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat Sequence or animation indefinitely. <br /></td></tr>
<tr class="separator:gace600ef49d59abf22dbaad7b5018d746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77075c217c0911bc6ea68dbdc73787e6"><td class="memItemLeft" align="right" valign="top"><a id="ga77075c217c0911bc6ea68dbdc73787e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga77075c217c0911bc6ea68dbdc73787e6">PLAY_DURATION_INFINITE</a>&#160;&#160;&#160;UINT32_MAX</td></tr>
<tr class="memdesc:ga77075c217c0911bc6ea68dbdc73787e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration of Sequence or animation is infinite. <br /></td></tr>
<tr class="separator:ga77075c217c0911bc6ea68dbdc73787e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35ab5cb43abaeb0798f19f30a077c21"><td class="memItemLeft" align="right" valign="top"><a id="gab35ab5cb43abaeb0798f19f30a077c21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gab35ab5cb43abaeb0798f19f30a077c21">GEdgeInsets4</a>(t,  r,  b,  l)&#160;&#160;&#160;((<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = t, .right = r, .bottom = b, .left = l})</td></tr>
<tr class="memdesc:gab35ab5cb43abaeb0798f19f30a077c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> macro <br /></td></tr>
<tr class="separator:gab35ab5cb43abaeb0798f19f30a077c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5df1ff8865d2032e680a2cf84311e1a"><td class="memItemLeft" align="right" valign="top"><a id="gae5df1ff8865d2032e680a2cf84311e1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gae5df1ff8865d2032e680a2cf84311e1a">GEdgeInsets3</a>(t,  rl,  b)&#160;&#160;&#160;((<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = t, .right = rl, .bottom = b, .left = rl})</td></tr>
<tr class="memdesc:gae5df1ff8865d2032e680a2cf84311e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> macro <br /></td></tr>
<tr class="separator:gae5df1ff8865d2032e680a2cf84311e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab130dc3e0dc8d5b4b47c12b02ee9a22e"><td class="memItemLeft" align="right" valign="top"><a id="gab130dc3e0dc8d5b4b47c12b02ee9a22e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gab130dc3e0dc8d5b4b47c12b02ee9a22e">GEdgeInsets2</a>(tb,  rl)&#160;&#160;&#160;((<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = tb, .right = rl, .bottom = tb, .left = rl})</td></tr>
<tr class="memdesc:gab130dc3e0dc8d5b4b47c12b02ee9a22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> macro <br /></td></tr>
<tr class="separator:gab130dc3e0dc8d5b4b47c12b02ee9a22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35765ba41b7bd443ac54356610599549"><td class="memItemLeft" align="right" valign="top"><a id="ga35765ba41b7bd443ac54356610599549"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga35765ba41b7bd443ac54356610599549">GEdgeInsets1</a>(trbl)&#160;&#160;&#160;((<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = trbl, .right = trbl, .bottom = trbl, .left = trbl})</td></tr>
<tr class="memdesc:ga35765ba41b7bd443ac54356610599549"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> macro <br /></td></tr>
<tr class="separator:ga35765ba41b7bd443ac54356610599549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1524bd1b8af82ffca01955db009076a6"><td class="memItemLeft" align="right" valign="top"><a id="ga1524bd1b8af82ffca01955db009076a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga1524bd1b8af82ffca01955db009076a6">GEdgeInsetsN</a>(_1,  _2,  _3,  _4,  NAME, ...)&#160;&#160;&#160;NAME</td></tr>
<tr class="memdesc:ga1524bd1b8af82ffca01955db009076a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper for <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> macro <br /></td></tr>
<tr class="separator:ga1524bd1b8af82ffca01955db009076a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aae5f60210e82dd8a9accda8b3df573"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga0aae5f60210e82dd8a9accda8b3df573">GEdgeInsets</a>(...)&#160;&#160;&#160;<a class="el" href="group__GraphicsTypes.html#ga1524bd1b8af82ffca01955db009076a6">GEdgeInsetsN</a>(__VA_ARGS__, <a class="el" href="group__GraphicsTypes.html#gab35ab5cb43abaeb0798f19f30a077c21">GEdgeInsets4</a>, <a class="el" href="group__GraphicsTypes.html#gae5df1ff8865d2032e680a2cf84311e1a">GEdgeInsets3</a>, <a class="el" href="group__GraphicsTypes.html#gab130dc3e0dc8d5b4b47c12b02ee9a22e">GEdgeInsets2</a>, <a class="el" href="group__GraphicsTypes.html#ga35765ba41b7bd443ac54356610599549">GEdgeInsets1</a>)(__VA_ARGS__)</td></tr>
<tr class="separator:ga0aae5f60210e82dd8a9accda8b3df573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga206a6919d369fe19e1bcbdc7611f15bf"><td class="memItemLeft" align="right" valign="top"><a id="ga206a6919d369fe19e1bcbdc7611f15bf"></a>
typedef union <a class="el" href="unionGColor8.html">GColor8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GColor8</b></td></tr>
<tr class="separator:ga206a6919d369fe19e1bcbdc7611f15bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b74248edea0c97b98702660c0251aa7"><td class="memItemLeft" align="right" valign="top"><a id="ga7b74248edea0c97b98702660c0251aa7"></a>
typedef <a class="el" href="unionGColor8.html">GColor8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GColor</b></td></tr>
<tr class="separator:ga7b74248edea0c97b98702660c0251aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56183984dbd226df3239884fa50b94f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structGPoint.html">GPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gad56183984dbd226df3239884fa50b94f">GPoint</a></td></tr>
<tr class="separator:gad56183984dbd226df3239884fa50b94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0bf8a877bc4f6f666aa9df2a87e714"><td class="memItemLeft" align="right" valign="top"><a id="ga6a0bf8a877bc4f6f666aa9df2a87e714"></a>
typedef struct <a class="el" href="structGSize.html">GSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga6a0bf8a877bc4f6f666aa9df2a87e714">GSize</a></td></tr>
<tr class="memdesc:ga6a0bf8a877bc4f6f666aa9df2a87e714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 2-dimensional size. <br /></td></tr>
<tr class="separator:ga6a0bf8a877bc4f6f666aa9df2a87e714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8daacf10d17e2297f5255e743836406d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga8daacf10d17e2297f5255e743836406d">GRect</a></td></tr>
<tr class="separator:ga8daacf10d17e2297f5255e743836406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b80c946027d25c34414008b460748d7"><td class="memItemLeft" align="right" valign="top"><a id="ga1b80c946027d25c34414008b460748d7"></a>
typedef enum <a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga1b80c946027d25c34414008b460748d7">GBitmapFormat</a></td></tr>
<tr class="memdesc:ga1b80c946027d25c34414008b460748d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of a GBitmap can either be 1-bit or 8-bit. <br /></td></tr>
<tr class="separator:ga1b80c946027d25c34414008b460748d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0df2406540fa4c66b5bb2bfb6fe4e3"><td class="memItemLeft" align="right" valign="top"><a id="gaed0df2406540fa4c66b5bb2bfb6fe4e3"></a>
typedef struct GBitmap&#160;</td><td class="memItemRight" valign="bottom"><b>GBitmap</b></td></tr>
<tr class="separator:gaed0df2406540fa4c66b5bb2bfb6fe4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4efc3f23535c390cd81f0bae9a903c"><td class="memItemLeft" align="right" valign="top"><a id="gaab4efc3f23535c390cd81f0bae9a903c"></a>
typedef struct GBitmapSequence&#160;</td><td class="memItemRight" valign="bottom"><b>GBitmapSequence</b></td></tr>
<tr class="separator:gaab4efc3f23535c390cd81f0bae9a903c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fbafd2653ee5df326015a94993b9c48"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__GraphicsTypes.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga6fbafd2653ee5df326015a94993b9c48">GAlign</a></td></tr>
<tr class="separator:ga6fbafd2653ee5df326015a94993b9c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83252ff59db719f37ccbb80393c53e89"><td class="memItemLeft" align="right" valign="top"><a id="ga83252ff59db719f37ccbb80393c53e89"></a>
typedef struct GContext&#160;</td><td class="memItemRight" valign="bottom"><b>GContext</b></td></tr>
<tr class="separator:ga83252ff59db719f37ccbb80393c53e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5c29b6b52478182a01ec4863de80ebfa"><td class="memItemLeft" align="right" valign="top"><a id="ga5c29b6b52478182a01ec4863de80ebfa"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> { <br />
&#160;&#160;<b>GBitmapFormat1Bit</b> = 0, 
<b>GBitmapFormat8Bit</b>, 
<b>GBitmapFormat1BitPalette</b>, 
<b>GBitmapFormat2BitPalette</b>, 
<br />
&#160;&#160;<b>GBitmapFormat4BitPalette</b>, 
<b>GBitmapFormat8BitCircular</b>
<br />
 }</td></tr>
<tr class="memdesc:ga5c29b6b52478182a01ec4863de80ebfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The format of a GBitmap can either be 1-bit or 8-bit. <br /></td></tr>
<tr class="separator:ga5c29b6b52478182a01ec4863de80ebfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8aa0eb3d3065fde8d2d6f282fa47f6a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a> { <br />
&#160;&#160;<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aa51bd2083cb00987d9e770436985642b2">GAlignCenter</a>, 
<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aae47b90e410e218b1035083f7d6df8371">GAlignTopLeft</a>, 
<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aaa6582295979f7c0661f6b5c686a5a606">GAlignTopRight</a>, 
<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aa2791f2177d74ec6baf029a8e25f731d9">GAlignTop</a>, 
<br />
&#160;&#160;<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aab6fc58bfb9c295f87bee0e6d77b4d683">GAlignLeft</a>, 
<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0e09ed4f51fd1f8b81205a61405b6eeb">GAlignBottom</a>, 
<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aa91754028af85b5079e59025bc13bc021">GAlignRight</a>, 
<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aab7802cc31f96f00cc88cc9d9fd3d8467">GAlignBottomRight</a>, 
<br />
&#160;&#160;<a class="el" href="group__GraphicsTypes.html#ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0d082bc1a280106ce0c8ce60508ed44d">GAlignBottomLeft</a>
<br />
 }</td></tr>
<tr class="separator:gac8aa0eb3d3065fde8d2d6f282fa47f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d021422bd90a2a49e6c8d848e6d556f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga0d021422bd90a2a49e6c8d848e6d556f">GCompOp</a> { <br />
&#160;&#160;<a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa3d668fac5e660241746c082d7155e059">GCompOpAssign</a>, 
<a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa1ee43eff5811f9066ee8a94498e7d828">GCompOpAssignInverted</a>, 
<a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa30d689e91f2ce16dd949b4076fb76ce4">GCompOpOr</a>, 
<a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa0859125379c8687a92843a6db44fb7a6">GCompOpAnd</a>, 
<br />
&#160;&#160;<a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556faba6dadf20ebce8ba4c25ecf3c9a39142">GCompOpClear</a>, 
<a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6">GCompOpSet</a>
<br />
 }</td></tr>
<tr class="separator:ga0d021422bd90a2a49e6c8d848e6d556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga40df0077888f77ac5b0a07d8d7304a76"><td class="memItemLeft" align="right" valign="top"><a id="ga40df0077888f77ac5b0a07d8d7304a76"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga40df0077888f77ac5b0a07d8d7304a76">gcolor_equal</a> (<a class="el" href="unionGColor8.html">GColor8</a> x, <a class="el" href="unionGColor8.html">GColor8</a> y)</td></tr>
<tr class="memdesc:ga40df0077888f77ac5b0a07d8d7304a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if both colors are identical or both are invisible (i.e. both have alpha values of .a=0). <br /></td></tr>
<tr class="separator:ga40df0077888f77ac5b0a07d8d7304a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d02d53f14eef571f131c784a1eaf3c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionGColor8.html">GColor8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga5d02d53f14eef571f131c784a1eaf3c2">gcolor_legible_over</a> (<a class="el" href="unionGColor8.html">GColor8</a> background_color)</td></tr>
<tr class="separator:ga5d02d53f14eef571f131c784a1eaf3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55941ba733d6b685ba3fcd316ce12af0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga55941ba733d6b685ba3fcd316ce12af0">gpoint_equal</a> (const <a class="el" href="structGPoint.html">GPoint</a> *const point_a, const <a class="el" href="structGPoint.html">GPoint</a> *const point_b)</td></tr>
<tr class="separator:ga55941ba733d6b685ba3fcd316ce12af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182655c93aaff5c2df45aba496c64b7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga182655c93aaff5c2df45aba496c64b7e">gsize_equal</a> (const <a class="el" href="structGSize.html">GSize</a> *size_a, const <a class="el" href="structGSize.html">GSize</a> *size_b)</td></tr>
<tr class="separator:ga182655c93aaff5c2df45aba496c64b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4bfb1da25ab4fec1a84ffbc50a40bb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gac4bfb1da25ab4fec1a84ffbc50a40bb5">grect_equal</a> (const <a class="el" href="structGRect.html">GRect</a> *const rect_a, const <a class="el" href="structGRect.html">GRect</a> *const rect_b)</td></tr>
<tr class="separator:gac4bfb1da25ab4fec1a84ffbc50a40bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbece2417a145e398e6c1ce512203150"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gabbece2417a145e398e6c1ce512203150">grect_is_empty</a> (const <a class="el" href="structGRect.html">GRect</a> *const rect)</td></tr>
<tr class="separator:gabbece2417a145e398e6c1ce512203150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcd8b24daede67494e49fa4803760a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga6fcd8b24daede67494e49fa4803760a8">grect_standardize</a> (<a class="el" href="structGRect.html">GRect</a> *rect)</td></tr>
<tr class="separator:ga6fcd8b24daede67494e49fa4803760a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be9e99bf608e20c4ce33c48a859efa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga0be9e99bf608e20c4ce33c48a859efa6">grect_clip</a> (<a class="el" href="structGRect.html">GRect</a> *const rect_to_clip, const <a class="el" href="structGRect.html">GRect</a> *const rect_clipper)</td></tr>
<tr class="separator:ga0be9e99bf608e20c4ce33c48a859efa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8952ac950ca4ec1195106e7b208a82c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga8952ac950ca4ec1195106e7b208a82c0">grect_contains_point</a> (const <a class="el" href="structGRect.html">GRect</a> *rect, const <a class="el" href="structGPoint.html">GPoint</a> *point)</td></tr>
<tr class="separator:ga8952ac950ca4ec1195106e7b208a82c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3a0a9c97927d0a72f3c5d8340e950fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGPoint.html">GPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gae3a0a9c97927d0a72f3c5d8340e950fd">grect_center_point</a> (const <a class="el" href="structGRect.html">GRect</a> *rect)</td></tr>
<tr class="separator:gae3a0a9c97927d0a72f3c5d8340e950fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ade8bcee6668a5b9fc3a5dc2adbb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga45ade8bcee6668a5b9fc3a5dc2adbb4c">grect_crop</a> (<a class="el" href="structGRect.html">GRect</a> rect, const int32_t crop_size_px)</td></tr>
<tr class="separator:ga45ade8bcee6668a5b9fc3a5dc2adbb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032629d36d12d13aadfd5176fd0463c8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga032629d36d12d13aadfd5176fd0463c8">gbitmap_get_bytes_per_row</a> (const GBitmap *bitmap)</td></tr>
<tr class="separator:ga032629d36d12d13aadfd5176fd0463c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c8c92415f93744d2a5aec9cb40194c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga3c8c92415f93744d2a5aec9cb40194c8">gbitmap_get_format</a> (const GBitmap *bitmap)</td></tr>
<tr class="separator:ga3c8c92415f93744d2a5aec9cb40194c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb0f0a071e491d8e96be6bc8ccb921cf"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gacb0f0a071e491d8e96be6bc8ccb921cf">gbitmap_get_data</a> (const GBitmap *bitmap)</td></tr>
<tr class="separator:gacb0f0a071e491d8e96be6bc8ccb921cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f2a0d2488f425a710864e127d1d327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga64f2a0d2488f425a710864e127d1d327">gbitmap_set_data</a> (GBitmap *bitmap, uint8_t *data, <a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> format, uint16_t row_size_bytes, bool free_on_destroy)</td></tr>
<tr class="separator:ga64f2a0d2488f425a710864e127d1d327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafce95e410fee76c66526f167c8415f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gafce95e410fee76c66526f167c8415f3f">gbitmap_get_bounds</a> (const GBitmap *bitmap)</td></tr>
<tr class="separator:gafce95e410fee76c66526f167c8415f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ef230f384923b9d02b735ac7c0aa7e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga3ef230f384923b9d02b735ac7c0aa7e4">gbitmap_set_bounds</a> (GBitmap *bitmap, <a class="el" href="structGRect.html">GRect</a> bounds)</td></tr>
<tr class="separator:ga3ef230f384923b9d02b735ac7c0aa7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a2945409ae7b2485a1b509dfc1333e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionGColor8.html">GColor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga89a2945409ae7b2485a1b509dfc1333e">gbitmap_get_palette</a> (const GBitmap *bitmap)</td></tr>
<tr class="separator:ga89a2945409ae7b2485a1b509dfc1333e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4450b2f567703a3e27bcbb51117aa087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a> (GBitmap *bitmap, <a class="el" href="unionGColor8.html">GColor</a> *palette, bool free_on_destroy)</td></tr>
<tr class="separator:ga4450b2f567703a3e27bcbb51117aa087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1c7c90641f5138b5f36f9334d52085a"><td class="memItemLeft" align="right" valign="top">GBitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gae1c7c90641f5138b5f36f9334d52085a">gbitmap_create_with_resource</a> (uint32_t resource_id)</td></tr>
<tr class="separator:gae1c7c90641f5138b5f36f9334d52085a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c01fd1816c6c0fde05310141f293cc5"><td class="memItemLeft" align="right" valign="top">GBitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga0c01fd1816c6c0fde05310141f293cc5">gbitmap_create_with_data</a> (const uint8_t *data)</td></tr>
<tr class="separator:ga0c01fd1816c6c0fde05310141f293cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d86515990747e47a76c0a16ed6b2850"><td class="memItemLeft" align="right" valign="top">GBitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga5d86515990747e47a76c0a16ed6b2850">gbitmap_create_as_sub_bitmap</a> (const GBitmap *base_bitmap, <a class="el" href="structGRect.html">GRect</a> sub_rect)</td></tr>
<tr class="separator:ga5d86515990747e47a76c0a16ed6b2850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ab3b20588760558364911972b7db142"><td class="memItemLeft" align="right" valign="top">GBitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga5ab3b20588760558364911972b7db142">gbitmap_create_from_png_data</a> (const uint8_t *png_data, size_t png_data_size)</td></tr>
<tr class="separator:ga5ab3b20588760558364911972b7db142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa300cd8eadcfe00bd05c3b1eebf22687"><td class="memItemLeft" align="right" valign="top">GBitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gaa300cd8eadcfe00bd05c3b1eebf22687">gbitmap_create_blank</a> (<a class="el" href="structGSize.html">GSize</a> size, <a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> format)</td></tr>
<tr class="separator:gaa300cd8eadcfe00bd05c3b1eebf22687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaecee8293ad845287bd4e1d90bc55782"><td class="memItemLeft" align="right" valign="top">GBitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gaaecee8293ad845287bd4e1d90bc55782">gbitmap_create_blank_with_palette</a> (<a class="el" href="structGSize.html">GSize</a> size, <a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> format, <a class="el" href="unionGColor8.html">GColor</a> *palette, bool free_on_destroy)</td></tr>
<tr class="separator:gaaecee8293ad845287bd4e1d90bc55782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f0e7cfe57c24bf2d2bb80e08ed6ad6"><td class="memItemLeft" align="right" valign="top">GBitmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gaa4f0e7cfe57c24bf2d2bb80e08ed6ad6">gbitmap_create_palettized_from_1bit</a> (const GBitmap *src_bitmap)</td></tr>
<tr class="separator:gaa4f0e7cfe57c24bf2d2bb80e08ed6ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b0540c1de9ecadbef44e7d87e05ca92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy</a> (GBitmap *bitmap)</td></tr>
<tr class="separator:ga0b0540c1de9ecadbef44e7d87e05ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dba771fd88df27504b17e4bc2b08d64"><td class="memItemLeft" align="right" valign="top">GBitmapSequence *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga3dba771fd88df27504b17e4bc2b08d64">gbitmap_sequence_create_with_resource</a> (uint32_t resource_id)</td></tr>
<tr class="separator:ga3dba771fd88df27504b17e4bc2b08d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7029b68fc5f0b6a8869a0aa7717fdc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga0f7029b68fc5f0b6a8869a0aa7717fdc">gbitmap_sequence_update_bitmap_next_frame</a> (GBitmapSequence *bitmap_sequence, GBitmap *bitmap, uint32_t *delay_ms)</td></tr>
<tr class="separator:ga0f7029b68fc5f0b6a8869a0aa7717fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c9b86d6acd020cbe4982d00cfd80ff6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga7c9b86d6acd020cbe4982d00cfd80ff6">gbitmap_sequence_update_bitmap_by_elapsed</a> (GBitmapSequence *bitmap_sequence, GBitmap *bitmap, uint32_t elapsed_ms)</td></tr>
<tr class="separator:ga7c9b86d6acd020cbe4982d00cfd80ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e569d755b657753e3508db7f3738ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga80e569d755b657753e3508db7f3738ff">gbitmap_sequence_destroy</a> (GBitmapSequence *bitmap_sequence)</td></tr>
<tr class="separator:ga80e569d755b657753e3508db7f3738ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38f7d5f9f91c51ba1735ff570ee83f08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga38f7d5f9f91c51ba1735ff570ee83f08">gbitmap_sequence_restart</a> (GBitmapSequence *bitmap_sequence)</td></tr>
<tr class="separator:ga38f7d5f9f91c51ba1735ff570ee83f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga310e83ec73f9bf4615be74f70875bb14"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga310e83ec73f9bf4615be74f70875bb14">gbitmap_sequence_get_current_frame_idx</a> (GBitmapSequence *bitmap_sequence)</td></tr>
<tr class="separator:ga310e83ec73f9bf4615be74f70875bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2baea5c5caff4c96de103895e63e66e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga2baea5c5caff4c96de103895e63e66e8">gbitmap_sequence_get_total_num_frames</a> (GBitmapSequence *bitmap_sequence)</td></tr>
<tr class="separator:ga2baea5c5caff4c96de103895e63e66e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9043176bcb76648ea06178359cf49956"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga9043176bcb76648ea06178359cf49956">gbitmap_sequence_get_play_count</a> (GBitmapSequence *bitmap_sequence)</td></tr>
<tr class="separator:ga9043176bcb76648ea06178359cf49956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb2389a62d110a0b36c05fec3026b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gaccb2389a62d110a0b36c05fec3026b45">gbitmap_sequence_set_play_count</a> (GBitmapSequence *bitmap_sequence, uint32_t play_count)</td></tr>
<tr class="separator:gaccb2389a62d110a0b36c05fec3026b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f780293a25c9533e3a7f225e5e32110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGSize.html">GSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga0f780293a25c9533e3a7f225e5e32110">gbitmap_sequence_get_bitmap_size</a> (GBitmapSequence *bitmap_sequence)</td></tr>
<tr class="separator:ga0f780293a25c9533e3a7f225e5e32110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c307d3424e0af8d03d988bb69a5ee0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGBitmapDataRowInfo.html">GBitmapDataRowInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga5c307d3424e0af8d03d988bb69a5ee0b">gbitmap_get_data_row_info</a> (const GBitmap *bitmap, uint16_t y)</td></tr>
<tr class="separator:ga5c307d3424e0af8d03d988bb69a5ee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad714d5d1dd0509196d8aadbdba2ac510"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#gad714d5d1dd0509196d8aadbdba2ac510">grect_align</a> (<a class="el" href="structGRect.html">GRect</a> *rect, const <a class="el" href="structGRect.html">GRect</a> *inside_rect, const <a class="el" href="group__GraphicsTypes.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a> alignment, const bool clip)</td></tr>
<tr class="separator:gad714d5d1dd0509196d8aadbdba2ac510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818b4cc0be88f40cbaf6a4b73497ae56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGRect.html">GRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GraphicsTypes.html#ga818b4cc0be88f40cbaf6a4b73497ae56">grect_inset</a> (<a class="el" href="structGRect.html">GRect</a> rect, <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> insets)</td></tr>
<tr class="separator:ga818b4cc0be88f40cbaf6a4b73497ae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Basic graphics types (point, rect, size, color, bitmaps, etc.) and utility functions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8cb8f728e01e63674935d7601f438841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cb8f728e01e63674935d7601f438841">&#9670;&nbsp;</a></span>COLOR_FALLBACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COLOR_FALLBACK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">color, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bw&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(color)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience macro allowing use of a fallback color for black and white platforms. On color platforms, the first expression will be chosen, the second otherwise. </p>

</div>
</div>
<a id="ga3c778a69b007e2dd2aeb2a8253d2a3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c778a69b007e2dd2aeb2a8253d2a3ad">&#9670;&nbsp;</a></span>GColorFromHEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromHEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__GraphicsTypes.html#ga5526fda29291b139ceb4c736f7aa61e4">GColorFromRGB</a>(((v) &gt;&gt; 16) &amp; 0xff, ((v) &gt;&gt; 8) &amp; 0xff, ((v) &amp; 0xff))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert hex integer to GColor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Integer hex value (e.g. 0x64ff46) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the hex value </dd></dl>

</div>
</div>
<a id="ga5526fda29291b139ceb4c736f7aa61e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5526fda29291b139ceb4c736f7aa61e4">&#9670;&nbsp;</a></span>GColorFromRGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromRGB</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">red, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">green, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blue&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__GraphicsTypes.html#gaa7922ac35d2b7fd40547083eed4ed757">GColorFromRGBA</a>(red, green, blue, 255)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert RGB to GColor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red</td><td>Red value from 0 - 255 </td></tr>
    <tr><td class="paramname">green</td><td>Green value from 0 - 255 </td></tr>
    <tr><td class="paramname">blue</td><td>Blue value from 0 - 255 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the RGB values </dd></dl>

</div>
</div>
<a id="gaa7922ac35d2b7fd40547083eed4ed757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7922ac35d2b7fd40547083eed4ed757">&#9670;&nbsp;</a></span>GColorFromRGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GColorFromRGBA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">red, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">green, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">blue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alpha&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((<a class="code" href="unionGColor8.html">GColor8</a>){ \</div>
<div class="line">  .a = (uint8_t)(alpha) &gt;&gt; 6, \</div>
<div class="line">  .r = (uint8_t)(red) &gt;&gt; 6, \</div>
<div class="line">  .g = (uint8_t)(green) &gt;&gt; 6, \</div>
<div class="line">  .b = (uint8_t)(blue) &gt;&gt; 6, \</div>
<div class="line">  })</div>
</div><!-- fragment --><p>Convert RGBA to GColor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">red</td><td>Red value from 0 - 255 </td></tr>
    <tr><td class="paramname">green</td><td>Green value from 0 - 255 </td></tr>
    <tr><td class="paramname">blue</td><td>Blue value from 0 - 255 </td></tr>
    <tr><td class="paramname">alpha</td><td>Alpha value from 0 - 255 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GColor created from the RGB values </dd></dl>

</div>
</div>
<a id="ga0aae5f60210e82dd8a9accda8b3df573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aae5f60210e82dd8a9accda8b3df573">&#9670;&nbsp;</a></span>GEdgeInsets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__GraphicsTypes.html#ga1524bd1b8af82ffca01955db009076a6">GEdgeInsetsN</a>(__VA_ARGS__, <a class="el" href="group__GraphicsTypes.html#gab35ab5cb43abaeb0798f19f30a077c21">GEdgeInsets4</a>, <a class="el" href="group__GraphicsTypes.html#gae5df1ff8865d2032e680a2cf84311e1a">GEdgeInsets3</a>, <a class="el" href="group__GraphicsTypes.html#gab130dc3e0dc8d5b4b47c12b02ee9a22e">GEdgeInsets2</a>, <a class="el" href="group__GraphicsTypes.html#ga35765ba41b7bd443ac54356610599549">GEdgeInsets1</a>)(__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience macro to make a <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> This macro follows the CSS shorthand notation where you can call it with</p><ul>
<li>just one value <a class="el" href="group__GraphicsTypes.html#ga0aae5f60210e82dd8a9accda8b3df573">GEdgeInsets(v1)</a> to configure all edges with v1 (<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = v1, .right = v1, .bottom = v1, .left = v1}</li>
<li>two values v1, v2 to configure a vertical and horizontal inset as (<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = v1, .right = v2, .bottom = v1, .left = v2}</li>
<li>three values v1, v2, v3 to configure it with (<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = v1, .right = v2, .bottom = v3, .left = v2}</li>
<li>four values v1, v2, v3, v4 to configure it with (<a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>){.top = v1, .right = v2, .bottom = v3, .left = v4} <dl class="section see"><dt>See also</dt><dd>grect_insets </dd></dl>
</li>
</ul>

</div>
</div>
<a id="gaa7ac313277ed0b20e858ba4f8f0f039d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7ac313277ed0b20e858ba4f8f0f039d">&#9670;&nbsp;</a></span>PBL_IF_BW_ELSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBL_IF_BW_ELSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_true, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_false&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(if_false)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience macro to switch between two expression depending on the screen of the platform. On black&amp; white platforms, the first expression will be chosen, the second otherwise. </p>

</div>
</div>
<a id="ga5a7411380c062d7024c411bdc0794206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7411380c062d7024c411bdc0794206">&#9670;&nbsp;</a></span>PBL_IF_COLOR_ELSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBL_IF_COLOR_ELSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_true, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_false&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(if_true)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience macro to switch between two expression depending on the screen of the platform. On color platforms, the first expression will be chosen, the second otherwise. </p>

</div>
</div>
<a id="ga93dc1082b2412cc4931cc1f0e870e250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93dc1082b2412cc4931cc1f0e870e250">&#9670;&nbsp;</a></span>PBL_IF_RECT_ELSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBL_IF_RECT_ELSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_true, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_false&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(if_true)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience macro to switch between two expression depending on the screen of the platform. On platforms with rectangular screen, the first expression will be chosen, the second otherwise. </p>

</div>
</div>
<a id="ga4f9bce65d188c24cbb92dcce0c616e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f9bce65d188c24cbb92dcce0c616e2c">&#9670;&nbsp;</a></span>PBL_IF_ROUND_ELSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PBL_IF_ROUND_ELSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_true, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">if_false&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(if_false)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience macro to switch between two expression depending on the screen of the platform. On platforms with round screen, the first expression will be chosen, the second otherwise. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6fbafd2653ee5df326015a94993b9c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fbafd2653ee5df326015a94993b9c48">&#9670;&nbsp;</a></span>GAlign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__GraphicsTypes.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a> <a class="el" href="group__GraphicsTypes.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values to specify how two things should be aligned relative to each other. <img src="galign.png" alt="" class="inline"/> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__BitmapLayer.html#ga4c1765f9330890641c4c09ba7e894894">bitmap_layer_set_alignment()</a> </dd></dl>

</div>
</div>
<a id="gad56183984dbd226df3239884fa50b94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56183984dbd226df3239884fa50b94f">&#9670;&nbsp;</a></span>GPoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structGPoint.html">GPoint</a> <a class="el" href="structGPoint.html">GPoint</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a point in a 2-dimensional coordinate system. </p><dl class="section note"><dt>Note</dt><dd>Conventionally, the origin of Pebble's 2D coordinate system is in the upper, lefthand corner its x-axis extends to the right and its y-axis extends to the bottom of the screen. </dd></dl>

</div>
</div>
<a id="ga8daacf10d17e2297f5255e743836406d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8daacf10d17e2297f5255e743836406d">&#9670;&nbsp;</a></span>GRect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structGRect.html">GRect</a> <a class="el" href="structGRect.html">GRect</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a rectangle and defining it using the origin of the upper-lefthand corner and its size. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac8aa0eb3d3065fde8d2d6f282fa47f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8aa0eb3d3065fde8d2d6f282fa47f6a">&#9670;&nbsp;</a></span>GAlign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__GraphicsTypes.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values to specify how two things should be aligned relative to each other. <img src="galign.png" alt="" class="inline"/> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__BitmapLayer.html#ga4c1765f9330890641c4c09ba7e894894">bitmap_layer_set_alignment()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa51bd2083cb00987d9e770436985642b2"></a>GAlignCenter&#160;</td><td class="fielddoc"><p>Align by centering. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aae47b90e410e218b1035083f7d6df8371"></a>GAlignTopLeft&#160;</td><td class="fielddoc"><p>Align by making the top edges overlap and left edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aaa6582295979f7c0661f6b5c686a5a606"></a>GAlignTopRight&#160;</td><td class="fielddoc"><p>Align by making the top edges overlap and left edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa2791f2177d74ec6baf029a8e25f731d9"></a>GAlignTop&#160;</td><td class="fielddoc"><p>Align by making the top edges overlap and centered horizontally. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aab6fc58bfb9c295f87bee0e6d77b4d683"></a>GAlignLeft&#160;</td><td class="fielddoc"><p>Align by making the left edges overlap and centered vertically. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0e09ed4f51fd1f8b81205a61405b6eeb"></a>GAlignBottom&#160;</td><td class="fielddoc"><p>Align by making the bottom edges overlap and centered horizontally. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa91754028af85b5079e59025bc13bc021"></a>GAlignRight&#160;</td><td class="fielddoc"><p>Align by making the right edges overlap and centered vertically. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aab7802cc31f96f00cc88cc9d9fd3d8467"></a>GAlignBottomRight&#160;</td><td class="fielddoc"><p>Align by making the bottom edges overlap and right edges overlap. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac8aa0eb3d3065fde8d2d6f282fa47f6aa0d082bc1a280106ce0c8ce60508ed44d"></a>GAlignBottomLeft&#160;</td><td class="fielddoc"><p>Align by making the bottom edges overlap and left edges overlap. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga0d021422bd90a2a49e6c8d848e6d556f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d021422bd90a2a49e6c8d848e6d556f">&#9670;&nbsp;</a></span>GCompOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__GraphicsTypes.html#ga0d021422bd90a2a49e6c8d848e6d556f">GCompOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Values to specify how the source image should be composited onto the destination image.</p>
<p><img src="compops.png" alt="" class="inline"/> Contrived example of how the different compositing modes affect drawing. Often, the "destination image" is the render buffer and thus contains the image of what has been drawn before or "underneath".</p>
<p>For color displays, only two compositing modes are supported, <a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa3d668fac5e660241746c082d7155e059">GCompOpAssign</a> and <a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6">GCompOpSet</a>. The behavior of other compositing modes are undefined and may change in the future. Transparency can be achieved using <a class="el" href="group__GraphicsTypes.html#gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6">GCompOpSet</a> and requires pixel values with alpha value .a &lt; 3. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__BitmapLayer.html#ga7bc761ca8227881c5853cbc0e279385e">bitmap_layer_set_compositing_mode()</a> </dd>
<dd>
<a class="el" href="group__GraphicsContext.html#ga64bc6cc5f86dabcd4b3cfa9fcffa328c">graphics_context_set_compositing_mode()</a> </dd>
<dd>
<a class="el" href="group__Drawing.html#ga2df0bc47f542ea60500d3070670725f9">graphics_draw_bitmap_in_rect()</a> </dd>
<dd>
<a class="el" href="group__Drawing.html#ga34f27bdfadc25a04b7b49d5cd8011266">graphics_draw_rotated_bitmap()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0d021422bd90a2a49e6c8d848e6d556fa3d668fac5e660241746c082d7155e059"></a>GCompOpAssign&#160;</td><td class="fielddoc"><p>Assign the pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. For color displays, when drawing a palettized or 8-bit GBitmap image, the opacity value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0d021422bd90a2a49e6c8d848e6d556fa1ee43eff5811f9066ee8a94498e7d828"></a>GCompOpAssignInverted&#160;</td><td class="fielddoc"><p>Assign the <b>inverted</b> pixel values of the source image to the destination pixels, effectively replacing the previous values for those pixels. </p><dl class="section note"><dt>Note</dt><dd>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga0d021422bd90a2a49e6c8d848e6d556fa30d689e91f2ce16dd949b4076fb76ce4"></a>GCompOpOr&#160;</td><td class="fielddoc"><p>Use the boolean operator <code>OR</code> to composite the source and destination pixels. The visual result of this compositing mode is the source's white pixels are painted onto the destination and the source's black pixels are treated as clear. </p><dl class="section note"><dt>Note</dt><dd>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga0d021422bd90a2a49e6c8d848e6d556fa0859125379c8687a92843a6db44fb7a6"></a>GCompOpAnd&#160;</td><td class="fielddoc"><p>Use the boolean operator <code>AND</code> to composite the source and destination pixels. The visual result of this compositing mode is the source's black pixels are painted onto the destination and the source's white pixels are treated as clear. </p><dl class="section note"><dt>Note</dt><dd>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga0d021422bd90a2a49e6c8d848e6d556faba6dadf20ebce8ba4c25ecf3c9a39142"></a>GCompOpClear&#160;</td><td class="fielddoc"><p>Clears the bits in the destination image, using the source image as mask. The visual result of this compositing mode is that for the parts where the source image is white, the destination image will be painted black. Other parts will be left untouched. </p><dl class="section note"><dt>Note</dt><dd>For bitmaps with a format different from GBitmapFormat1Bit, this mode is not supported and the resulting behavior is undefined. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga0d021422bd90a2a49e6c8d848e6d556fa3ca84b5c70798643a3bd07b263c47fe6"></a>GCompOpSet&#160;</td><td class="fielddoc"><p>Sets the bits in the destination image, using the source image as mask. This mode is required to apply any transparency of your bitmap. </p><dl class="section note"><dt>Note</dt><dd>For bitmaps of the format GBitmapFormat1Bit, the visual result of this compositing mode is that for the parts where the source image is black, the destination image will be painted white. Other parts will be left untouched. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5d86515990747e47a76c0a16ed6b2850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d86515990747e47a76c0a16ed6b2850">&#9670;&nbsp;</a></span>gbitmap_create_as_sub_bitmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_as_sub_bitmap </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>base_bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>sub_rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new GBitmap on the heap as a sub-bitmap of a 'base' GBitmap, using a <a class="el" href="structGRect.html">GRect</a> to indicate what portion of the base to use. The sub-bitmap will just reference the image data and palette of the base bitmap. No deep-copying occurs as a result of calling this function, thus the caller is responsible for making sure the base bitmap and palette will remain available when using the sub-bitmap. Note that you should not destroy the parent bitmap until the sub_bitmap has been destroyed. The resulting GBitmap must be destroyed using <a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base_bitmap</td><td>The bitmap that the sub-bitmap of which the image data will be used by the sub-bitmap </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sub_rect</td><td>The rectangle within the image data of the base bitmap. The bounds of the base bitmap will be used to clip <code>sub_rect</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a id="gaa300cd8eadcfe00bd05c3b1eebf22687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa300cd8eadcfe00bd05c3b1eebf22687">&#9670;&nbsp;</a></span>gbitmap_create_blank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_blank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGSize.html">GSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new blank GBitmap on the heap initialized to zeroes. In the case that the format indicates a palettized bitmap, a palette of appropriate size will also be allocated on the heap. The resulting GBitmap must be destroyed using <a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The Pebble image dimensions as a <a class="el" href="structGSize.html">GSize</a>. </td></tr>
    <tr><td class="paramname">format</td><td>The <a class="el" href="group__GraphicsTypes.html#ga1b80c946027d25c34414008b460748d7">GBitmapFormat</a> the created image should be in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a id="gaaecee8293ad845287bd4e1d90bc55782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaecee8293ad845287bd4e1d90bc55782">&#9670;&nbsp;</a></span>gbitmap_create_blank_with_palette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_blank_with_palette </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGSize.html">GSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionGColor8.html">GColor</a> *&#160;</td>
          <td class="paramname"><em>palette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new blank GBitmap on the heap, initialized to zeroes, and assigns it the given palette. No deep-copying of the palette occurs, so the caller is responsible for making sure the palette remains available when using the resulting bitmap. Management of that memory can be handed off to the system with the free_on_destroy argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The Pebble image dimensions as a <a class="el" href="structGSize.html">GSize</a>. </td></tr>
    <tr><td class="paramname">format</td><td>the <a class="el" href="group__GraphicsTypes.html#ga1b80c946027d25c34414008b460748d7">GBitmapFormat</a> the created image and palette should be in. </td></tr>
    <tr><td class="paramname">palette</td><td>a pointer to a palette that is to be used for this GBitmap. The palette should be large enough to hold enough colors for the specified format. For example, GBitmapFormat2BitPalette should have 4 colors, since 2^2 = 4. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the palette data should be freed along with the bitmap data when the GBitmap is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created. </dd></dl>

</div>
</div>
<a id="ga5ab3b20588760558364911972b7db142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ab3b20588760558364911972b7db142">&#9670;&nbsp;</a></span>gbitmap_create_from_png_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_from_png_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>png_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>png_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a GBitmap based on raw PNG data. The resulting GBitmap must be destroyed using <a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. The developer is responsible for freeing png_data following this call. </p><dl class="section note"><dt>Note</dt><dd>PNG decoding currently supports 1,2,4 and 8 bit palettized and grayscale images. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">png_data</td><td>PNG image data. </td></tr>
    <tr><td class="paramname">png_data_size</td><td>PNG image size in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a id="gaa4f0e7cfe57c24bf2d2bb80e08ed6ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f0e7cfe57c24bf2d2bb80e08ed6ad6">&#9670;&nbsp;</a></span>gbitmap_create_palettized_from_1bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_palettized_from_1bit </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>src_bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a 1-bit GBitmap, create a new bitmap of format GBitmapFormat1BitPalette. The new data buffer is allocated on the heap, and a 2-color palette is allocated as well. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_bitmap</td><td>A GBitmap of format GBitmapFormat1Bit which is to be copied into a newly created GBitmap of format GBitmapFormat1BitPalettized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created 1-bit palettized GBitmap, or NULL if there is not sufficient space. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The new bitmap does not depend on any data from src_bitmap, so src_bitmap can be freed without worry. </dd></dl>

</div>
</div>
<a id="ga0c01fd1816c6c0fde05310141f293cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c01fd1816c6c0fde05310141f293cc5">&#9670;&nbsp;</a></span>gbitmap_create_with_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_with_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new GBitmap on the heap initialized with the provided Pebble image data.</p>
<p>The resulting GBitmap must be destroyed using <a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a> but the image data will not be freed automatically. The developer is responsible for keeping the image data in memory as long as the bitmap is used and releasing it after the bitmap is destroyed. </p><dl class="section note"><dt>Note</dt><dd>One way to generate Pebble image data is to use bitmapgen.py in the Pebble SDK to generate a .pbi file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The Pebble image data. Must not be NULL. The function assumes the data to be correct; there are no sanity checks performed on the data. The data will not be copied and the pointer must remain valid for the lifetime of this GBitmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a id="gae1c7c90641f5138b5f36f9334d52085a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1c7c90641f5138b5f36f9334d52085a">&#9670;&nbsp;</a></span>gbitmap_create_with_resource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmap* gbitmap_create_with_resource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resource_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new GBitmap on the heap using a Pebble image file stored as a resource. The resulting GBitmap must be destroyed using <a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_id</td><td>The ID of the bitmap resource to load </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the GBitmap. <code>NULL</code> if the GBitmap could not be created </dd></dl>

</div>
</div>
<a id="ga0b0540c1de9ecadbef44e7d87e05ca92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b0540c1de9ecadbef44e7d87e05ca92">&#9670;&nbsp;</a></span>gbitmap_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_destroy </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a GBitmap. This must be called for every bitmap that's been created with gbitmap_create_*</p>
<p>This function will also free the memory of the bitmap data (bitmap-&gt;addr) if the bitmap was created with <a class="el" href="group__GraphicsTypes.html#gaa300cd8eadcfe00bd05c3b1eebf22687">gbitmap_create_blank()</a> or <a class="el" href="group__GraphicsTypes.html#gae1c7c90641f5138b5f36f9334d52085a">gbitmap_create_with_resource()</a>.</p>
<p>If the GBitmap was created with <a class="el" href="group__GraphicsTypes.html#ga0c01fd1816c6c0fde05310141f293cc5">gbitmap_create_with_data()</a>, you must release the memory after calling <a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy()</a>. </p>

</div>
</div>
<a id="gafce95e410fee76c66526f167c8415f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafce95e410fee76c66526f167c8415f3f">&#9670;&nbsp;</a></span>gbitmap_get_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGRect.html">GRect</a> gbitmap_get_bounds </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the bounds of the content for the GBitmap. This is set when loading the image or if changed by <a class="el" href="group__GraphicsTypes.html#ga3ef230f384923b9d02b735ac7c0aa7e4">gbitmap_set_bounds</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the bounding box from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bounding box for the GBitmap. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#ga3ef230f384923b9d02b735ac7c0aa7e4">gbitmap_set_bounds</a> </dd></dl>

</div>
</div>
<a id="ga032629d36d12d13aadfd5176fd0463c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032629d36d12d13aadfd5176fd0463c8">&#9670;&nbsp;</a></span>gbitmap_get_bytes_per_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t gbitmap_get_bytes_per_row </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of bytes per row in the bitmap data for the given GBitmap. On rectangular displays, this can be used as a safe way of iterating over the rows in the bitmap, since bytes per row should be set according to format. On circular displays with pixel format of GBitmapFormat8BitCircular this will return 0, and should not be used for iteration over frame buffer pixels. Instead, use <a class="el" href="structGBitmapDataRowInfo.html">GBitmapDataRowInfo</a>, which provides safe minimum and maximum x values for a given row's y value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the bytes per row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes per row of the GBitmap </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#gacb0f0a071e491d8e96be6bc8ccb921cf">gbitmap_get_data</a> </dd></dl>

</div>
</div>
<a id="gacb0f0a071e491d8e96be6bc8ccb921cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb0f0a071e491d8e96be6bc8ccb921cf">&#9670;&nbsp;</a></span>gbitmap_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* gbitmap_get_data </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the raw image data section of the given GBitmap as specified by the format of the bitmap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the raw image data for the GBitmap </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#ga032629d36d12d13aadfd5176fd0463c8">gbitmap_get_bytes_per_row</a> </dd>
<dd>
GBitmap </dd></dl>

</div>
</div>
<a id="ga5c307d3424e0af8d03d988bb69a5ee0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c307d3424e0af8d03d988bb69a5ee0b">&#9670;&nbsp;</a></span>gbitmap_get_data_row_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGBitmapDataRowInfo.html">GBitmapDataRowInfo</a> gbitmap_get_data_row_info </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides information about a pixel data row </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get row info </td></tr>
    <tr><td class="paramname">y</td><td>Absolute row number in the pixel data, independent from the bitmap's bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Description of the row </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not respect the bitmap's bounds but purely operates on the pixel data. This function works with every bitmap format including GBitmapFormat1Bit. The result of the function for invalid rows is undefined. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#gacb0f0a071e491d8e96be6bc8ccb921cf">gbitmap_get_data</a> </dd></dl>

</div>
</div>
<a id="ga3c8c92415f93744d2a5aec9cb40194c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c8c92415f93744d2a5aec9cb40194c8">&#9670;&nbsp;</a></span>gbitmap_get_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a> gbitmap_get_format </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the <a class="el" href="group__GraphicsTypes.html#ga1b80c946027d25c34414008b460748d7">GBitmapFormat</a> for the GBitmap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The format of the given GBitmap. </dd></dl>

</div>
</div>
<a id="ga89a2945409ae7b2485a1b509dfc1333e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89a2945409ae7b2485a1b509dfc1333e">&#9670;&nbsp;</a></span>gbitmap_get_palette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionGColor8.html">GColor</a>* gbitmap_get_palette </td>
          <td>(</td>
          <td class="paramtype">const GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the palette for the given GBitmap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to get the palette from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a GColor array containing the palette colors. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a> </dd></dl>

</div>
</div>
<a id="ga3dba771fd88df27504b17e4bc2b08d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dba771fd88df27504b17e4bc2b08d64">&#9670;&nbsp;</a></span>gbitmap_sequence_create_with_resource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GBitmapSequence* gbitmap_sequence_create_with_resource </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resource_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a GBitmapSequence from the specified resource (APNG/PNG files) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resource_id</td><td>Resource to load and create GBitmapSequence from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GBitmapSequence pointer if the resource was loaded, NULL otherwise </dd></dl>

</div>
</div>
<a id="ga80e569d755b657753e3508db7f3738ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80e569d755b657753e3508db7f3738ff">&#9670;&nbsp;</a></span>gbitmap_sequence_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_sequence_destroy </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the GBitmapSequence structure and frees any allocated memory/decoder_data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to the bitmap sequence to free (delete) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f780293a25c9533e3a7f225e5e32110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f780293a25c9533e3a7f225e5e32110">&#9670;&nbsp;</a></span>gbitmap_sequence_get_bitmap_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGSize.html">GSize</a> gbitmap_sequence_get_bitmap_size </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the minimum required size (dimensions) necessary to render the bitmap sequence to a GBitmap using the /ref gbitmap_sequence_update_bitmap_next_frame </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dimensions required to render the bitmap sequence to a GBitmap </dd></dl>

</div>
</div>
<a id="ga310e83ec73f9bf4615be74f70875bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga310e83ec73f9bf4615be74f70875bb14">&#9670;&nbsp;</a></span>gbitmap_sequence_get_current_frame_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gbitmap_sequence_get_current_frame_idx </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the current frame number for the bitmap sequence </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of current frame in the current loop of the bitmap sequence </dd></dl>

</div>
</div>
<a id="ga9043176bcb76648ea06178359cf49956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9043176bcb76648ea06178359cf49956">&#9670;&nbsp;</a></span>gbitmap_sequence_get_play_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t gbitmap_sequence_get_play_count </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function gets the play count (number of times to repeat) the bitmap sequence </p><dl class="section note"><dt>Note</dt><dd>This value is initialized by the bitmap sequence data, and is modified by <a class="el" href="group__GraphicsTypes.html#gaccb2389a62d110a0b36c05fec3026b45">gbitmap_sequence_set_play_count</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Play count of bitmap sequence, PLAY_COUNT_INFINITE for infinite looping </dd></dl>

</div>
</div>
<a id="ga2baea5c5caff4c96de103895e63e66e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2baea5c5caff4c96de103895e63e66e8">&#9670;&nbsp;</a></span>gbitmap_sequence_get_total_num_frames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t gbitmap_sequence_get_total_num_frames </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the total number of frames for the bitmap sequence </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of frames contained in a single loop of the bitmap sequence </dd></dl>

</div>
</div>
<a id="ga38f7d5f9f91c51ba1735ff570ee83f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38f7d5f9f91c51ba1735ff570ee83f08">&#9670;&nbsp;</a></span>gbitmap_sequence_restart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gbitmap_sequence_restart </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restarts the GBitmapSequence to the first frame <a class="el" href="group__GraphicsTypes.html#ga0f7029b68fc5f0b6a8869a0aa7717fdc">gbitmap_sequence_update_bitmap_next_frame</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sequence was restarted, false otherwise </dd></dl>

</div>
</div>
<a id="gaccb2389a62d110a0b36c05fec3026b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccb2389a62d110a0b36c05fec3026b45">&#9670;&nbsp;</a></span>gbitmap_sequence_set_play_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_sequence_set_play_count </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>play_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function sets the play count (number of times to repeat) the bitmap sequence </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
    <tr><td class="paramname">play_count</td><td>Number of times to repeat the bitmap sequence with 0 disabling update_by_elapsed and update_next_frame, and PLAY_COUNT_INFINITE for infinite looping of the animation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c9b86d6acd020cbe4982d00cfd80ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c9b86d6acd020cbe4982d00cfd80ff6">&#9670;&nbsp;</a></span>gbitmap_sequence_update_bitmap_by_elapsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gbitmap_sequence_update_bitmap_by_elapsed </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elapsed_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the contents of the bitmap sequence to the frame at elapsed in the sequence. For looping animations this accounts for the loop, for example an animation of 1 second that is configured to loop 2 times updated to 1500 ms elapsed time will display the sequence frame at 500 ms. Elapsed time is the time from the start of the animation, and will be ignored if it is for a time earlier than the last rendered frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
    <tr><td class="paramname">bitmap</td><td>Pointer to the initialized GBitmap in which to render the bitmap sequence </td></tr>
    <tr><td class="paramname">elapsed_ms</td><td>Elapsed time in milliseconds in the sequence relative to start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a frame was rendered. False if all frames (and loops) have already been rendered for the sequence. Will also return false if frame could not be rendered (includes out of memory errors). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>GBitmap must be large enough to accommodate the bitmap_sequence image <a class="el" href="group__GraphicsTypes.html#ga0f780293a25c9533e3a7f225e5e32110">gbitmap_sequence_get_bitmap_size</a> </dd>
<dd>
This function is disabled for play_count 0 </dd></dl>

</div>
</div>
<a id="ga0f7029b68fc5f0b6a8869a0aa7717fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7029b68fc5f0b6a8869a0aa7717fdc">&#9670;&nbsp;</a></span>gbitmap_sequence_update_bitmap_next_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gbitmap_sequence_update_bitmap_next_frame </td>
          <td>(</td>
          <td class="paramtype">GBitmapSequence *&#160;</td>
          <td class="paramname"><em>bitmap_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>delay_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the contents of the bitmap sequence to the next frame and optionally returns the delay in milliseconds until the next frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">bitmap_sequence</td><td>Pointer to loaded bitmap sequence </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bitmap</td><td>Pointer to the initialized GBitmap in which to render the bitmap sequence </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">delay_ms</td><td>If not NULL, returns the delay in milliseconds until the next frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if frame was rendered. False if all frames (and loops) have been rendered for the sequence. Will also return false if frame could not be rendered (includes out of memory errors). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>GBitmap must be large enough to accommodate the bitmap_sequence image <a class="el" href="group__GraphicsTypes.html#ga0f780293a25c9533e3a7f225e5e32110">gbitmap_sequence_get_bitmap_size</a> </dd></dl>

</div>
</div>
<a id="ga3ef230f384923b9d02b735ac7c0aa7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ef230f384923b9d02b735ac7c0aa7e4">&#9670;&nbsp;</a></span>gbitmap_set_bounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_bounds </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the bounds of the given GBitmap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set the bounding box. </td></tr>
    <tr><td class="paramname">bounds</td><td>The bounding box to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#gafce95e410fee76c66526f167c8415f3f">gbitmap_get_bounds</a> </dd></dl>

</div>
</div>
<a id="ga64f2a0d2488f425a710864e127d1d327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64f2a0d2488f425a710864e127d1d327">&#9670;&nbsp;</a></span>gbitmap_set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_data </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__GraphicsTypes.html#ga5c29b6b52478182a01ec4863de80ebfa">GBitmapFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>row_size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the bitmap data for the given GBitmap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set data to </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the bitmap data </td></tr>
    <tr><td class="paramname">format</td><td>the format of the bitmap data. If this is a palettized format, make sure that there is an accompanying call to <a class="el" href="group__GraphicsTypes.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a>. </td></tr>
    <tr><td class="paramname">row_size_bytes</td><td>How many bytes a single row takes. For example, bitmap data of format GBitmapFormat1Bit must have a row size as a multiple of 4 bytes. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the data should be freed when the GBitmap is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy</a> </dd></dl>

</div>
</div>
<a id="ga4450b2f567703a3e27bcbb51117aa087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4450b2f567703a3e27bcbb51117aa087">&#9670;&nbsp;</a></span>gbitmap_set_palette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gbitmap_set_palette </td>
          <td>(</td>
          <td class="paramtype">GBitmap *&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionGColor8.html">GColor</a> *&#160;</td>
          <td class="paramname"><em>palette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_destroy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the palette for the given GBitmap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>A pointer to the GBitmap to set the palette to </td></tr>
    <tr><td class="paramname">palette</td><td>The palette to be used. Make sure that the palette is large enough for the bitmap's format. </td></tr>
    <tr><td class="paramname">free_on_destroy</td><td>Set whether the palette data should be freed when the GBitmap is destroyed or when another palette is set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__GraphicsTypes.html#ga3c8c92415f93744d2a5aec9cb40194c8">gbitmap_get_format</a> </dd>
<dd>
<a class="el" href="group__GraphicsTypes.html#ga0b0540c1de9ecadbef44e7d87e05ca92">gbitmap_destroy</a> </dd>
<dd>
<a class="el" href="group__GraphicsTypes.html#ga4450b2f567703a3e27bcbb51117aa087">gbitmap_set_palette</a> </dd></dl>

</div>
</div>
<a id="ga5d02d53f14eef571f131c784a1eaf3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d02d53f14eef571f131c784a1eaf3c2">&#9670;&nbsp;</a></span>gcolor_legible_over()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionGColor8.html">GColor8</a> gcolor_legible_over </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionGColor8.html">GColor8</a>&#160;</td>
          <td class="paramname"><em>background_color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method assists in improving the legibility of text on various background colors. It takes the background color for the region in question and computes a color for maximum legibility. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">background_color</td><td>Background color for the region in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A legible color for the given background color </dd></dl>

</div>
</div>
<a id="ga55941ba733d6b685ba3fcd316ce12af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55941ba733d6b685ba3fcd316ce12af0">&#9670;&nbsp;</a></span>gpoint_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpoint_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGPoint.html">GPoint</a> *const&#160;</td>
          <td class="paramname"><em>point_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGPoint.html">GPoint</a> *const&#160;</td>
          <td class="paramname"><em>point_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether 2 points are equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_a</td><td>Pointer to the first point </td></tr>
    <tr><td class="paramname">point_b</td><td>Pointer to the second point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both points are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="gad714d5d1dd0509196d8aadbdba2ac510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad714d5d1dd0509196d8aadbdba2ac510">&#9670;&nbsp;</a></span>grect_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGRect.html">GRect</a> *&#160;</td>
          <td class="paramname"><em>inside_rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__GraphicsTypes.html#gac8aa0eb3d3065fde8d2d6f282fa47f6a">GAlign</a>&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aligns one rectangle within another rectangle, using an alignment parameter. The relative coordinate systems of both rectangles are assumed to be the same. When clip is true, <code>rect</code> is also clipped by the constraint. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>The rectangle to align (in place) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect</td><td>The aligned and optionally clipped rectangle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inside_rect</td><td>The rectangle in which to align <code>rect</code> </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">alignment</td><td>Determines the alignment of <code>rect</code> within <code>inside_rect</code> by specifying what edges of should overlap. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">clip</td><td>Determines whether <code>rect</code> should be trimmed using the edges of <code>inside_rect</code> in case <code>rect</code> extends outside of the area that <code>inside_rect</code> covers after the alignment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3a0a9c97927d0a72f3c5d8340e950fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3a0a9c97927d0a72f3c5d8340e950fd">&#9670;&nbsp;</a></span>grect_center_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGPoint.html">GPoint</a> grect_center_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGRect.html">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to compute the center-point of a given rectangle. This is equal to <code>(rect-&gt;x + rect-&gt;width / 2, rect-&gt;y + rect-&gt;height / 2)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle for which to calculate the center point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The point at the center of <code>rect</code> </dd></dl>

</div>
</div>
<a id="ga0be9e99bf608e20c4ce33c48a859efa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be9e99bf608e20c4ce33c48a859efa6">&#9670;&nbsp;</a></span>grect_clip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_clip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_to_clip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGRect.html">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_clipper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trim one rectangle using the edges of a second rectangle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect_to_clip</td><td>The rectangle that needs to be clipped (in place). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect_to_clip</td><td>The clipped rectangle. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rect_clipper</td><td>The rectangle of which the edges will serve as "scissors" in order to trim <code>rect_to_clip</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8952ac950ca4ec1195106e7b208a82c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8952ac950ca4ec1195106e7b208a82c0">&#9670;&nbsp;</a></span>grect_contains_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_contains_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGRect.html">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGPoint.html">GPoint</a> *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether a rectangle contains a point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle </td></tr>
    <tr><td class="paramname">point</td><td>The point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rectangle contains the point, or <code>false</code> if it does not. </dd></dl>

</div>
</div>
<a id="ga45ade8bcee6668a5b9fc3a5dc2adbb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ade8bcee6668a5b9fc3a5dc2adbb4c">&#9670;&nbsp;</a></span>grect_crop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGRect.html">GRect</a> grect_crop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>crop_size_px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduce the width and height of a rectangle by insetting each of the edges with a fixed inset. The returned rectangle will be centered relative to the input rectangle. </p><dl class="section note"><dt>Note</dt><dd>The function will trip an assertion if the crop yields a rectangle with negative width or height. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle that will be inset </td></tr>
    <tr><td class="paramname">crop_size_px</td><td>The inset by which each of the rectangle will be inset. A positive inset value results in a smaller rectangle, while negative inset value results in a larger rectangle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cropped rectangle. </dd></dl>

</div>
</div>
<a id="gac4bfb1da25ab4fec1a84ffbc50a40bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4bfb1da25ab4fec1a84ffbc50a40bb5">&#9670;&nbsp;</a></span>grect_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGRect.html">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGRect.html">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether 2 rectangles are equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect_a</td><td>Pointer to the first rectangle </td></tr>
    <tr><td class="paramname">rect_b</td><td>Pointer to the second rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both rectangles are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="ga818b4cc0be88f40cbaf6a4b73497ae56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga818b4cc0be88f40cbaf6a4b73497ae56">&#9670;&nbsp;</a></span>grect_inset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGRect.html">GRect</a> grect_inset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGEdgeInsets.html">GEdgeInsets</a>&#160;</td>
          <td class="paramname"><em>insets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a rectangle that is shrinked or expanded by the given edge insets. </p><dl class="section note"><dt>Note</dt><dd>The rectangle is standardized and then the inset parameters are applied. If the resulting rectangle would have a negative height or width, a GRectZero is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle that will be inset </td></tr>
    <tr><td class="paramname">insets</td><td>The insets that will be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting rectangle </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function in together with the <a class="el" href="structGEdgeInsets.html">GEdgeInsets</a> macro <div class="fragment"><div class="line"><a class="code" href="structGRect.html">GRect</a> r_inset_all_sides = <a class="code" href="group__GraphicsTypes.html#ga818b4cc0be88f40cbaf6a4b73497ae56">grect_inset</a>(r, <a class="code" href="group__GraphicsTypes.html#ga0aae5f60210e82dd8a9accda8b3df573">GEdgeInsets</a>(10));</div>
<div class="line"><a class="code" href="structGRect.html">GRect</a> r_inset_vertical_horizontal = <a class="code" href="group__GraphicsTypes.html#ga818b4cc0be88f40cbaf6a4b73497ae56">grect_inset</a>(r, <a class="code" href="group__GraphicsTypes.html#ga0aae5f60210e82dd8a9accda8b3df573">GEdgeInsets</a>(10, 20));</div>
<div class="line"><a class="code" href="structGRect.html">GRect</a> r_expand_top_right_shrink_bottom_left = <a class="code" href="group__GraphicsTypes.html#ga818b4cc0be88f40cbaf6a4b73497ae56">grect_inset</a>(r, <a class="code" href="group__GraphicsTypes.html#ga0aae5f60210e82dd8a9accda8b3df573">GEdgeInsets</a>(-10, -10, 10, 10));</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gabbece2417a145e398e6c1ce512203150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbece2417a145e398e6c1ce512203150">&#9670;&nbsp;</a></span>grect_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grect_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGRect.html">GRect</a> *const&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether the size of the rectangle is (0, 0). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>Pointer to the rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the rectangle its size is (0, 0), or <code>false</code> if not. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the width and/or height of a rectangle is negative, this function will return <code>true</code>! </dd></dl>

</div>
</div>
<a id="ga6fcd8b24daede67494e49fa4803760a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fcd8b24daede67494e49fa4803760a8">&#9670;&nbsp;</a></span>grect_standardize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void grect_standardize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGRect.html">GRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a rectangle's values so that the components of its size (width and/or height) are both positive. In the width and/or height are negative, the origin will offset, so that the final rectangle overlaps with the original. For example, a <a class="el" href="structGRect.html">GRect</a> with size (-10, -5) and origin (20, 20), will be standardized to size (10, 5) and origin (10, 15). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rect</td><td>The rectangle to convert. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rect</td><td>The standardized rectangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga182655c93aaff5c2df45aba496c64b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182655c93aaff5c2df45aba496c64b7e">&#9670;&nbsp;</a></span>gsize_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gsize_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structGSize.html">GSize</a> *&#160;</td>
          <td class="paramname"><em>size_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structGSize.html">GSize</a> *&#160;</td>
          <td class="paramname"><em>size_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether 2 sizes are equal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_a</td><td>Pointer to the first size </td></tr>
    <tr><td class="paramname">size_b</td><td>Pointer to the second size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both sizes are equal, <code>false</code> if not. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__GraphicsTypes_html_ga818b4cc0be88f40cbaf6a4b73497ae56"><div class="ttname"><a href="group__GraphicsTypes.html#ga818b4cc0be88f40cbaf6a4b73497ae56">grect_inset</a></div><div class="ttdeci">GRect grect_inset(GRect rect, GEdgeInsets insets)</div></div>
<div class="ttc" id="agroup__GraphicsTypes_html_ga0aae5f60210e82dd8a9accda8b3df573"><div class="ttname"><a href="group__GraphicsTypes.html#ga0aae5f60210e82dd8a9accda8b3df573">GEdgeInsets</a></div><div class="ttdeci">#define GEdgeInsets(...)</div><div class="ttdef"><b>Definition:</b> pebble.h:3845</div></div>
<div class="ttc" id="astructGRect_html"><div class="ttname"><a href="structGRect.html">GRect</a></div><div class="ttdef"><b>Definition:</b> pebble.h:3357</div></div>
<div class="ttc" id="aunionGColor8_html"><div class="ttname"><a href="unionGColor8.html">GColor8</a></div><div class="ttdef"><b>Definition:</b> pebble.h:3268</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
